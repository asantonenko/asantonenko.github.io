<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<p>Отже, розберемося, як відбувається робота з масивами в стилі Сі на низькому рівні. Річ у тім, що у мовах C/C++ масив у стилі Сі не є повноцінним типом. Наприклад:</p>

<ul>
	<li>масив не може бути повернений з функції як значення;</li>
	<li>не можна передати масив у функцію за значенням (тільки через вказівник або посилання).</li>
</ul>

<p>У мові С++, масив у стилі Сі автоматично перетворюється на вказівник на перший елемент масиву при виконанні майже будь-якої операції нам ним, окрім:</p>

<ol>
	<li>операції&nbsp;<strong>sizeof</strong>, яка, як Ви вже бачили, повертає розмір масиву в байтах, а не вказівника;</li>
	<li>передачі масиву в функцію за посиланням у мові&nbsp;C++ (<code>int (&amp;arr)[8]</code>).</li>
</ol>

<p>А що ж відбувається при зверненні до елемента масиву стилю Сі за індексом, наприклад,&nbsp;<code>arr[i]</code>? Давайте це розглянемо докладно. Нехай є масив:</p>

<pre><code class="language-cpp">int arr[8] = {5, 3, 30, 2, 5, 7, 3, 11};</code></pre>

<p>У пам'яті він представлений таким чином:</p>

<p style="text-align:center;"><img alt="" src="https://ucarecdn.com/6057e235-dca0-4a2a-a8f8-754340d52dec/"></p>

<p>Тут <code>arr</code> є весь масив, але при здійсненні доступу до елементів, він перетворюється на вказівник на перший елемент масиву (адресу першого елемента масиву), цей вказівник тут позначений як <code>arr + 0</code>. Під першим елементом мається на увазі елемент із нульовим індексом. Додавання цілого числа до вказівника означає зсув на задану кількість елементів базового типу вперед. Зокрема, <code>arr+1</code> свідчить про наступний за першим елемент, тобто. елемент з індексом 1. Зауважимо, що адреса <code>arr+1</code> не є адресою <code>arr</code> плюс 1 байт, а є адресою&nbsp;<code>arr</code> плюс <code><strong>sizeof</strong>(<strong>int</strong>)</code> байт. Припустимо, що <code>arr</code> починається в комірці з номером 100, а кожне ціле число розміщено в 4 байтах (тобто <code>sizeof(int)</code> дорівнює 4). Тоді в пам'яті масив розташовується так:</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:800px;">
	<thead>
		<tr>
			<th>Назва</th>
			<th>Позначення</th>
			<th>Початок</th>
			<th>Кінець</th>
			<th>Розмір</th>
			<th>Значення</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Весь масив</td>
			<td>arr</td>
			<td>100</td>
			<td>131</td>
			<td>4*8=32</td>
			<td>{5, 3, ..., 11}</td>
		</tr>
		<tr>
			<td>Перший елемент</td>
			<td>arr[0]</td>
			<td>100</td>
			<td>103</td>
			<td>4</td>
			<td>5</td>
		</tr>
		<tr>
			<td>Другий елемент</td>
			<td>arr[1]</td>
			<td>104</td>
			<td>107</td>
			<td>4</td>
			<td>3</td>
		</tr>
		<tr>
			<td>....</td>
			<td>....</td>
			<td>....</td>
			<td>....</td>
			<td>....</td>
			<td>....</td>
		</tr>
		<tr>
			<td>Останній елемент</td>
			<td>arr[7]</td>
			<td>128</td>
			<td>131</td>
			<td>4</td>
			<td>11</td>
		</tr>
	</tbody>
</table>

<p>Доступ до елемента <code>arr[i]</code> еквівалентний:</p>

<pre><code class="language-cpp">*(arr + i) // Зсув на i елементів + розіменування</code></pre>

<p>Це працює через властивості арифметики вказівників:</p>

<ul>
	<li><code>arr + i</code> = адреса початку масиву + <code>i * sizeof(int)</code></li>
	<li>Для <code>int</code> розміром 4 байти: <code>arr + 1</code> = 100 + 4 = 104</li>
</ul>

<p>Отже, <code>arr+0</code> вказує на елемент <code>arr[0]</code>, <code>arr+1</code> вказує на елемент <code>arr[1]</code> і т.д., <code>arr+i</code> вказує на елемент <code>arr[i]</code>. Щоб досягти самого елемента, потрібно провести так зване розіменування вказівника, яке позначається символом <code>*</code>. Отже, <code>arr[i]</code> для масиву в стилі Сі, це просто скорочений запис виразу <code>*(arr+i)</code>, що означає перетворення масиву на вказівник, зсув його на <code>i</code> позицій вперед і розімевання його. Оскільки ми знаємо, що від зміни місць доданків сума не змінюється, то можна записати і <code>*(i+arr)</code>, звідки є деяке дивовижне наслідок - скорочений запис <code>i[arr]</code> теж працює (позначає те саме, що і <code>arr[i]</code>), але це <strong>не рекомендується</strong> до використання!</p>

<h3>Відмінності від контейнерів C++</h3>

<pre><code class="language-cpp">vector&lt;int&gt; vec = {1, 2, 3};</code></pre>

<ul>
	<li>Неявне перетворення в вказівник <strong>неможливе</strong>.</li>
	<li>Оператор <code>[]</code>&nbsp;перевантажена.</li>
	<li>Містить метадані (розмір, ємність) разом з даними.</li>
</ul>

<p>Зауважимо, що для контейнерів мови C++ операція квадратні дужки <em>перевантажена</em> - і&nbsp;це вже не просто зрушення та розйменування вказівника, хоча до цього часто в результаті все і зводиться. Наприклад, клас <code>vector&lt;<strong>int</strong>&gt;</code> не є вказівником на ціле число і не може бути в нього неявно перетворений, але, швидше за все, <em>містить</em> всередині себе цей вказівник (поряд з розміром та ємністю масиву).</p>