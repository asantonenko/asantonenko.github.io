<p>При работе с побитовыми операциями используется двоичное представление чисел. Биты традиционно нумеруются начиная с младшего, причем самый младший бит нумеруется нулем.  Таким образом бит номер <span class="math-tex">\(i\)</span> отвечает за наличие в двоичном представлении числа степени равной <span class="math-tex">\(2^i\)</span>.</p>

<pre><code class="language-cpp">int x = 50, y = 100;

//в двоичном виде x = 0000 0000 0000 0000 0000 0000 0011 0010 = 2^5 + 2^4 + 2^1 = 32 + 16 + 2
//в двоичном виде y = 0000 0000 0000 0000 0000 0000 0110 0100 = 2^6 + 2^5 + 2^2 = 64 + 32 + 4</code></pre>

<p>Мы будем говорить, что в числе <code>y=100</code> установлены только три бита: 6-й, 5-й и 2-й (установлены те биты, где соответствующий разряд в двоичном представлении равен <code>1</code>). Мы записали 32-битные числа, дополнив недостающие разряды спереди нулями, предполагая, что размер значений типа <strong><code>int</code></strong> равен 32 битам (это так в большинстве случаев).</p>

<p>Приведем основные побитовые операции с целыми числами:</p>

<p>1. Проверка установлен ли <code>i</code>-тый бит в числе x?</p>

<pre><code class="language-cpp">if (x &amp; (1 &lt;&lt; i))
{
    cout &lt;&lt;i &lt;&lt;"-тый бит установлен (равен 1)." &lt;&lt; endl;
}
else
{
    cout &lt;&lt;i &lt;&lt;"-тый бит сброшен (равен 0)." &lt;&lt; endl;
}</code></pre>

<p>Как работает:</p>

<pre><code class="language-no-highlight">  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число x)
  &amp;
1 &lt;&lt; 0 = 0000 0000 0000 0000 0000 0000 0000 0001  (установлен бит номер 0)
  =      =======================================
  0    = 0000 0000 0000 0000 0000 0000 0000 0000  (ноль, т.к. бит номер 0 в числе x равен 0)

  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  &amp;
1 &lt;&lt; 1 = 0000 0000 0000 0000 0000 0000 0000 0010  (установлен бит номер 1)
  =      =======================================
1 &lt;&lt; 1 = 0000 0000 0000 0000 0000 0000 0000 0010  (бит номер 1, т.к. бит номер 1 в числе x равен 1)


  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число x)
  &amp;
1 &lt;&lt; 2 = 0000 0000 0000 0000 0000 0000 0000 0100  (установлен бит номер 2)
  =      =======================================
  0    = 0000 0000 0000 0000 0000 0000 0000 0000  (ноль, т.к. бит номер 2 в числе x равен 0)

---------------------------------------------------------------------------------------------------

  y    = 0000 0000 0000 0000 0000 0000 0110 0100  (число y)
  &amp;
1 &lt;&lt; 2 = 0000 0000 0000 0000 0000 0000 0000 0100  (установлен бит номер 2)
  =      =======================================
1 &lt;&lt; 2 = 0000 0000 0000 0000 0000 0000 0000 0100  (бит номер 2, т.к. бит номер 2 в числе y равен 1)</code></pre>

<p>Выражение <code>x &amp; (1 &lt;&lt; i)</code> оставляет только <code>i</code>-тый бит в числе. Когда оно используется в качестве логического в условии оператора <strong><code>if</code></strong>, то ненулевое значение (в случае, когда <code>i</code>-тый бит был равен 1) будет обозначать истинное значение, а нулевое (когда <code>i</code>-тый бит был равен 0) - ложное.</p>

<p>Отметим, что если Вы хотите использовать 64-битный тип <strong><code>long long,</code></strong> т.е. переменная <code>x</code> объявлена как </p>

<pre><code>long long x;</code></pre>

<p>то необходимо изменить проверку на </p>

<pre><code class="language-cpp">if (x &amp; (1LL &lt;&lt; i))
{
    cout &lt;&lt;i &lt;&lt;"-тый бит установлен (равен 1)." &lt;&lt; endl;
}
else
{
    cout &lt;&lt;i &lt;&lt;"-тый бит сброшен (равен 0)." &lt;&lt; endl;
}</code></pre>

<p>Нашли отличие? Мы использовали <code>1LL</code> - литерал типа <strong><code>long long</code></strong> вместо литерала <code>1</code> типа <strong><code>int</code></strong>, чтобы при сдвиге разряда влево единица не вышла за пределы разрядной сетки, при попытке проверить бит с номером <code>32</code> или больше. Аналогичные изменения нужно будет сделать и со всеми следующими примерами, если хотите использовать 64-битные числа.</p>

<p>2. Установить <code>i</code>-тый бит. Это означает сделать <code>i</code>-тый бит равным единице. Остальные биты не меняют своего значения.</p>

<pre><code class="language-cpp">x = x | (1 &lt;&lt; i);</code></pre>

<p>или более кратко </p>

<pre><code class="language-cpp">x |= 1 &lt;&lt; i;</code></pre>

<p> Пример:</p>

<pre><code>  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  |
1 &lt;&lt; 0 = 0000 0000 0000 0000 0000 0000 0000 0001  (установлен бит номер 0)
         =======================================
         0000 0000 0000 0000 0000 0000 0011 0011  (число x с дополнительно установленным битом номер 0)

  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  |
1 &lt;&lt; 1 = 0000 0000 0000 0000 0000 0000 0000 0010  (установлен бит номер 1)
  =      =======================================
  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (x не изменился, т.к. бит номер 1 в исходном числе был и так равен 1)


  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  |
1 &lt;&lt; 2 = 0000 0000 0000 0000 0000 0000 0000 0100  (установлен бит номер 2)
         =======================================
         0000 0000 0000 0000 0000 0000 0011 0110  (число x с дополнительно установленным битом номер 2)
</code></pre>

<p>Если <code>i</code>-тый бит и так был установлен, то число не изменяется.</p>

<p>3. Сбросить <code>i</code>-тый бит. Это означает сделать <code>i</code>-тый бит равным нулю. Остальные биты не меняют своего значения.</p>

<pre><code class="language-cpp">x = x &amp; ~(1 &lt;&lt; i);</code></pre>

<p>или более кратко  </p>

<pre><code class="language-cpp">x &amp;= ~(1 &lt;&lt; i);</code></pre>

<pre><code>    x     = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
    &amp;
~(1 &lt;&lt; 0) = 1111 1111 1111 1111 1111 1111 1111 1110  (установлены все биты, кроме бита номер 0)
    =       =======================================
    x       0000 0000 0000 0000 0000 0000 0011 0010  (x не изменился, т.к. бит номер 0 в исходном числе был и так равен 0)

    x     = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
    &amp;
~(1 &lt;&lt; 1) = 1111 1111 1111 1111 1111 1111 1111 1101  
            =======================================
            0000 0000 0000 0000 0000 0000 0011 0000  (сбросили бит номер 1 в числе x)
</code></pre>

<p> 4. Инвертировать  <code>i</code>-тый бит. Т.е. если <code>i</code>-тый бит был равен <code>0</code>, сделать его единицей и наоборот, если он был равен <code>1</code>, сделать его нулем. Остальные биты не меняют своего значения.</p>

<pre><code class="language-cpp">x = x ^ (1 &lt;&lt; i);</code></pre>

<p>или более кратко   </p>

<pre><code class="language-cpp">x ^= 1 &lt;&lt; i;</code></pre>

<p> </p>

<pre><code>  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  ^
1 &lt;&lt; 0 = 0000 0000 0000 0000 0000 0000 0000 0001  (установлен бит номер 0)
         =======================================
         0000 0000 0000 0000 0000 0000 0011 0011  (бит номер 0 изменился с 0 на 1)

  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  ^
1 &lt;&lt; 1 = 0000 0000 0000 0000 0000 0000 0000 0010  (установлен бит номер 1)
         =======================================
         0000 0000 0000 0000 0000 0000 0011 0000  (бит номер 1 изменился с 1 на 0)


  x    = 0000 0000 0000 0000 0000 0000 0011 0010  (исходное число)
  ^
1 &lt;&lt; 2 = 0000 0000 0000 0000 0000 0000 0000 0100  (установлен бит номер 2)
         =======================================
         0000 0000 0000 0000 0000 0000 0011 0110  (бит номер 2 изменился с 0 на 1)
</code></pre>

<p><strong>Литература</strong>: </p>

<p>1. Побитовые операции — Викиконспекты Университета ИТМО <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8" rel="noopener noreferrer nofollow">https://neerc.ifmo.ru/wiki/index.php?title=Побитовые_операции</a> </p>