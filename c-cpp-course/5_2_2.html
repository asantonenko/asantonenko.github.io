<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h1>Ітератори. Range-based for</h1>

<p>Для роботи з контейнерами можна використовувати й інший засіб — <em>ітератори</em>. Ітератори — це друге з основних понять бібліотеки STL. Ітератор призначений для вказівки на конкретний елемент контейнера, а також для послідовного перебору всіх елементів контейнера. Для цього існують дві основні операції над ітераторами: нехай <code>it</code> — це деякий ітератор, що вказує на певний елемент контейнера, тоді <code>++it</code> або <code>it++</code> перемістить ітератор на наступну позицію, а <code>*it</code> позначає той елемент контейнера, на який вказує ітератор.</p>

<p>Кожен контейнер надає ітератори на початок і кінець послідовності, використовуючи методи <code>begin()</code> та <code>end()</code>. Зверніть увагу, що <code>end()</code> повертає ітератор на фіктивний елемент — заглушку кінця контейнера. Доступ до цього елемента заборонений. У порожньому контейнері ця заглушка також присутня, і метод <code>begin()</code> у цьому випадку теж повертає ітератор на неї. Таким чином, контейнер <code>cont</code> порожній тоді й лише тоді, коли <code>cont.begin() == cont.end()</code>.</p>

<p>Нехай оголошено деякий вектор: <code>vector&lt;int&gt; vec;</code>. Тоді цикл, що використовує ітератори і виводить значення елементів вектора, має вигляд:</p>

<pre><code class="language-cpp">for (vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it)
{
    cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>

<p>Зазначимо важливу перевагу цього циклу — цикл через ітератори працює не лише для масивів, але й для інших контейнерів, таких як множина <code>set</code> та асоціативний масив <code>map</code>. На жаль, такий цикл досить громіздкий. Починаючи з версії C++11, його можна трохи спростити завдяки використанню ключового слова <strong>auto</strong>, що означає автоматичне визначення типу змінної компілятором (за типом значення, яке присвоюється). Тоді цикл набуде такого вигляду:</p>

<pre><code class="language-cpp">for (auto it = vec.begin(); it != vec.end(); ++it)
{
    cout &lt;&lt; *it &lt;&lt; " ";
}</code></pre>

<p>Все ще громіздко. Програмісту зазвичай потрібні цикли виду "для кожного елемента контейнера виконай ось це". Індекс або ітератор у такому випадку — зайва сутність, використання якої може призвести до помилок або описок. У багатьох мовах програмування існує оператор foreach ("для кожного"). Починаючи з версії C++11, подібний цикл з’явився і в мові C++, тільки називається він <em>range-based for</em> і має такий <strong>синтаксис</strong>:</p>

<p><code><strong>for </strong>(<em>тип</em> <em>елемент</em> : <em>контейнер</em>)</code></p>

<p><code>{</code></p>

<p><code>     // обробляємо <em>елемент</em></code></p>

<p><code>}</code></p>

<p>При цьому зазвичай як тип елемента вказують ключове слово <strong>auto</strong>, і тоді друк елементів будь-якого контейнера виглядає так:</p>

<pre><code class="language-cpp">for (auto el : vec)
{
    cout &lt;&lt; el &lt;&lt; " ";
}</code></pre>

<p>Тут <code>el</code> — це формальне ім’я елемента, і воно використовується для позначення елемента (замість конструкцій <code>vec[i]</code> або <code>*it</code>). Звісно, можна використовувати й інше ім’я змінної, не лише <code>el</code>. Зверніть увагу, що у змінну <code>el</code> будуть по черзі копіюватися значення елементів, тому такий цикл підходить не завжди. Якщо потрібно працювати із самими елементами, а не їх копіями, потрібно використовувати символ опису посилання <code>&amp;</code>. Наприклад, це потрібно для введення з клавіатури масиву. Припустімо, що у першому рядку задано кількість елементів, а у другому рядку — самі елементи вектора. Тоді для оголошення та введення вектора можна скористатися такими операторами:</p>

<pre><code class="language-cpp">int size;
cin &gt;&gt; size;

vector&lt;int&gt; vec(size);
for (auto&amp; el : vec)
{
    cin &gt;&gt; el;
}</code></pre>

<p>Спочатку ми вводимо розмір вектора — окрему змінну <code>size</code>, а потім оголошуємо вектор розміру <code>size</code> і вводимо по черзі кожен його елемент.</p>

<p>Також використання посилання на елемент контейнера (за допомогою символу <code>&amp;</code>) може знадобитися й тоді, коли ми не хочемо змінювати значення елемента контейнера, але він має досить великий розмір і його копіювання може бути надто тривалим. Припустимо, у нас є певний текст, який зберігається як вектор рядків. Нехай потрібно порахувати сумарну довжину рядків. Для цього зовсім не обов’язково їх копіювати, потрібно лише застосувати до кожної з них метод <code>length()</code> для визначення довжини рядка й додати ці довжини. Отримаємо такий код:</p>

<pre><code>vector&lt;string&gt; text;

// Якось заповнюємо змінну text

int total_length = 0; // спочатку загальна довжина дорівнює 0
for (const auto&amp; line : text) // для кожного рядка тексту
{
    total_length += line.length(); // додаємо до загальної довжини довжину поточного рядка
}

cout &lt;&lt; "Загальна кількість символів у тексті (не враховуючи переходи на новий рядок) дорівнює " &lt;&lt; total_length &lt;&lt; endl;</code></pre>

<p>У цьому коді використовується константне посилання, яке</p>

<ol>
	<li>дозволяє уникнути копіювання рядків;</li>
	<li>не дозволяє випадково змінити якийсь рядок тексту.</li>
</ol>

<p>Таким чином, нам вдалося чіткіше вказати, чого ми хочемо досягти. Крім того, якби сама змінна <code>vector&lt;string&gt; text;</code> була б оголошена з модифікатором <code><strong>const</strong></code>, тобто, наприклад, була б дійсно константою або була б передана у функцію за константним посиланням, то використати цикл <code><strong>for </strong>(<strong>auto</strong>&amp; line : text)</code> з не константним посиланням нам би заборонив компілятор — оскільки ми не мали б права змінювати змінну <code>text</code>, а значить і змінну <code>line</code>.</p>