<h1>Сі рядки</h1>

<p>Мова програмування C++ підтримує дісталися йому у спадок від мови C рядки, що являють собою вказівник на перший символ з деякої послідовності (масиву) символів, що обов&#39;язково включає в себе <em>нуль-символ</em> (символ з кодом нуль). Цей символ означає кінець рядка, тобто у рядок входять усі символи <em>до</em> нього. Сам нуль-символ у рядок не входить і при підрахунку довжини рядка не враховується.</p>

<p>Для оголошення такого рядка достатньо створити масив символів та присвоїти йому деяку послідовність, що містить нуль-символ. Наприклад,</p>

<pre>
<code>char s1[30]="1+2";</code></pre>

<p>чи</p>

<pre>
<code>char s2[30]={'1','+','2','\0'};</code></pre>

<p>Такі рядки називаються <em>Сі-рядками</em>, рядками в стилі Сі, рядками із завершальним нулем або рядками, що закінчуються на нуль-символ (англ.,&nbsp;<em>C-string</em> або <em>null terminated string</em>). Зауважимо, що незважаючи на різний синтаксис в даному випадку оголошено по суті два рядки однакового розміру і з однаковими значеннями: під обидва рядки виділено по 30 байт (символів) і туди записані символи <code>&#39;1&#39;</code>, знак&nbsp;<code>&#39;+&#39;</code>, цифра&nbsp;<code>&#39;2&#39;</code> і спеціальний нуль символ &ndash; символ із кодом нуль, який можна записати як&nbsp;<code>&#39;\0&#39;</code>. Зауважимо, що в першому масиві цей нуль-символ теж є &ndash; хоча він явно не вказаний, але синтаксис із подвійними лапками його має на увазі. Що записано після нуль символу не важливо, ці символи ігноруються (хоча за правилами мов C/C++ при оголошенні масивів усі невказані елементи заповнюються нулями, тобто нуль-символами в даному випадку).</p>

<p>Явний розмір буфера для рядка можна і не писати, компілятор може визначити його самостійно, якщо рядку надається деяке значення, як у прикладі вище. Можна записати так: &nbsp;</p>

<pre>
<code>char s3[]="1+2";</code></pre>

<p>чи</p>

<pre>
<code>char s4[]={'1','+','2','\0'};</code></pre>

<p>Під рядки <code>s3</code> та <code>s4</code> буде виділено по 4 байти (3 байти на корисні символи та нуль-символ). Але довжина всіх рядків <code>s1</code>, <code>s2</code>, <code>s3</code> та <code>s4</code> однакова і дорівнює трьом (у довжину рядка враховуються лише корисні символи до нуль-символу).</p>

<p>Зверніть увагу, що всі строкові константи, записані в подвійних лапках без додаткових специфікаторів, є рядками, тобто мають тип <code>char *</code> (точніше <code>const char *</code>) &ndash; тобто вказівник на символ.</p>

<p>Але Сі-рядки не дуже зручні у використанні. Для присвоєння цих рядків потрібно використовувати функцію <code>strcpy</code>, для порівняння &ndash; функцію <code>strcmp</code>, для конкатенації &ndash; функцію <code>strcat</code>. Також слід стежити, щоб довжина рядка не перевищила виділену для рядку пам&#39;ять (враховуючи один байт на нуль-символ), тобто якщо рядок оголошено</p>

<pre>
<code>char s[20];</code></pre>

<p>то його розмір не може перевищувати 19 символів (+нуль-символ). При спробі записати більше інформації відбудеться переповнення масиву і будуть зіпсовані значення інших змінних.</p>

<p>Наприклад, наступний фрагмент коду виконує запис у рядкову змінну <code>st1</code> у стилі Сі значення <code>&quot;Hello, world!&quot;</code></p>

<pre>
<code>char st1[20];
//...
strcpy(st1, "Hello, world!");</code></pre>

<p>Цей код є цілком коректним, так як довжина рядка <code>&quot;Hello, world!&quot;</code> дорівнює 13 символів, з урахуванням нуль-символу зайнято 14 байт з буфера на 20 байт, в інших елементах буфера знаходиться сміття, але з погляду мови Сі і роботи з Сі рядками все гаразд, оскільки програмний код ні в якому разі не повинен заглядати в байти рядка після завершального нуль-символу.</p>

<p>Якщо додати до кінця вищенаведеного коду ще один рядок</p>

<pre>
<code>strcat(st1, "!!");</code></pre>

<p>то в рядку <code>st1</code> буде зберігатися вже модифікований рядок&nbsp;<code>&quot;Hello, world!!!&quot;</code>&nbsp;довжиною 15 символів, а також нуль-символ. У буфері буде зайнято 16 байт із 20. При цьому операція strcat не може працювати швидко, хоча їй і треба тільки додати два символа та змістити нуль-символ, але їй доведеться переглянути весь рядок із самого початку та знайти позицію нуль-символа і починаючи з цієї позиції записати рядок <code>&quot;!!&quot;</code> та новий нуль-символ.</p>

<p>Але такі приклади коду некоректні і призведуть до непередбачуваних наслідків:</p>

<pre>
<code>char st2[10];
//...
strcpy(st2, "Hello, world!");</code></pre>

<p>чи</p>

<pre>
<code>char st3[20];
//...
strcpy(st3, "Hello, world!");
strcat(st3, " Hello, again!");</code></pre>

<p>оскільки відбудеться переповнення буферів <code>st2</code> та <code>st3</code>. Функції strcpy (для рядка st2) і strcat (для рядка st3) просто спробують записати інформацію за межі виділених буферів <code>st2</code> та <code>st3</code>, швидше за все, зіпсувавши значення сусідніх змінних. Немає жодної можливості в мові Сі написати функції <code>strcpy</code> і <code>strcat</code> з тією ж сигнатурою, що і стандартні функції, які перевіряли б на вихід за межі буфера і не писали в чужу пам&#39;ять. Правда в нових версіях є безпечні аналоги функцій. <code>strcpy</code> та <code>strcat</code> з іменами&nbsp; <code>strcpy_s</code> та <code>strcat_s</code> - див. [2] та [3].</p>

<p>Ще гірше буде якщо написати так:</p>

<pre>
<code>char st4[20];
strcat(st4, "Hello, again!");</code></pre>

<p>Тут рядок неініціалізований, але до нього ми намагаємося дописати до кінця деякий рядок. Як Ви вже знаєте, функція strcat шукатиме нуль-символ в кінці рядка <code>st4</code> і після нього дописуватиме рядок&nbsp;<code>&quot;Hello, again!&quot;</code>. Якщо припустити, що на початку буфера <code>st4</code> (у символі <code>st4[0]</code> з індексом <code>0</code>) буде нуль-символ, то все буде в порядку , і функція просто запише&nbsp;<code>&quot;Hello, again!&quot;</code> починаючи з самого початку буфера <code>st4</code> (ймовірність даного сценарію досить висока). Але оскільки масив <code>st4</code> є локальним неініціалізованим масивом у стилі Сі, тобто за стандартом мови містить сміття, то в ньому може і не виявитися нуль-символу, тоді функція <code>strcat</code> вирушить у подорож величезною ділянкою оперативної пам&#39;яті, поки їй не зустрінеться нуль-символ і запише туди<code>&quot;Hello , again!&quot;</code>. З погляду стандартів C/C++ ця штука є прикладом невизначеної поведінки (undefined behaviour, UB) і у цьому разі за стандартом може статися будь-що (нічого не гарантується).</p>

<p><strong>Література</strong>:</p>

<ol>
	<li>Null-terminated byte strings&nbsp;&mdash; cppreference.com&nbsp;<a href="https://en.cppreference.com/w/c/string/byte" rel="noopener noreferrer nofollow">https://en.cppreference.com/w/c/string/byte</a></li>
	<li>strcpy, strcpy_s &mdash; cppreference.com&nbsp;<a href="https://en.cppreference.com/w/c/string/byte/strcpy" rel="noopener noreferrer nofollow">https://en.cppreference.com/w/c/string/byte/strcpy</a>&nbsp;</li>
	<li>strcat, strcat_s &mdash; cppreference.com&nbsp;<a href="https://en.cppreference.com/w/c/string/byte/strcat" rel="noopener noreferrer nofollow">https://en.cppreference.com/w/c/string/byte/strcat</a></li>
</ol>
