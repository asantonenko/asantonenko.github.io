<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>
 <script type="text/javascript" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
 </script>

<h2>Заповнення та виведення двовимірного масиву</h2>

<p>Щоб обробити двовимірний масив, зазвичай потрібні вкладені цикли <strong><code>for</code></strong>. Найчастіше зовнішній цикл по рядках, а внутрішній по стовпчикам. Наприклад, заповнимо наш масив <code>revenue</code> фіксованими значеннями доходу, наприклад, числом <code>1.5</code>.</p>

<pre>
<code>for (int i = 0; i &lt; 4; i++)
{
    for (int j = 0; j &lt; 12; j++)
    {
         revenue[i][j] = 1.5;
    }
}</code></pre>

<p>У даному&nbsp;фрагменті використовуються магічні константи <code>4</code> і <code>12</code> (що позначають кількість відділів і місяців, відповідно), що не є добре. Те саме можна сказати і про магічне число <code>1.5</code>. Можна явно поставити ці константи:</p>

<pre>
<code>const int DEPARTMENT_QUANTITY = 4;
const int MONTH_QUANTITY = 12;

double revenue[DEPARTMENT_QUANTITY][MONTH_QUANTITY];

double startdart_revenue = 1.5;

for (int depno = 0; depno &lt; DEPARTMENT_QUANTITY; depno++)
{
    for (int month = 0; month &lt; MONTH_QUANTITY; month++)
    {
         revenue[depno][month] = startdart_revenue;
    }
}</code></pre>

<p>Я використовував змінну startdart_revenue, а не константу, тому що припустив, що в процесі роботи програми стандартний (нормативний) дохід відділу міг би потенційно і помінятися. А ось <code>DEPARTMENT_QUANTITY</code> та <code>MONTH_QUANTITY</code> є константами, так як кількість місяців точно незмінна, а також, хоч, потенційно, може бути доданий новий відділ, але наша структура даних - матриця фіксованого розділу не підтримує таку операцію, як зміни розміру. Більше того, у старих версіях мов C/C++ розміри матриці однозначно повинні бути задані константою, і хоча в C99 підтримуються runtime-sized arrays, а значить і подібні матриці, робота з ними вкрай утруднена, а у мові С++ вони взагалі нестандартні, тому ми не будемо зараз цим користуватися. Імена констант написані великими літерами відповідно до прийнятих у мові Сі угод. /p&gt;</p>

<p><em>Порада за стилем кодування</em>: Якщо у Вас є просто матриця з математики, або матриця, що містить деякі абстрактні значення (просто за завданням сказано, щось зробити з матрицею з чисел), то індекси у матриці логічніше називати <code>i</code> і <code>j</code> (за традицією). Але якщо індекси у Вас позначають номер місяця, номер відділу, номер людини, номер завдання тощо, то краще використовувати більш осмислені імена - як у прикладі вище.</p>

<p><strong>Приклад.</strong> Заповніть дві цілі матриці розмірами 5 на 4 випадковими числами в діапазоні від -10 до 10 (включно). Знайти суму даних матриць. Вивести вихідні матриці та їх суму.</p>

<p>Оскільки тут використовуються абстрактні (математичні) матриці, то назвемо їх як у математиці: матриці <span class="math-tex">\(A\)</span>, <span class="math-tex">\(B\)</span> і <span class="math-tex">\(C = A + B\)</span>. Розмір матриць позначимо константами <code>ROWS</code> (кількість рядків) і <code>COLS</code> (кількість стовпців).</p>

<p>Напишемо перший варіант програми:</p>

<pre>
<code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    const int ROWS = 5, COLS = 4;
    
    int A[ROWS][COLS], B[ROWS][COLS];
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            A[i][j] = -10 + rand() % 21;
        }
    }
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            B[i][j] = -10 + rand() % 21;
        }
    }
    
    int C[ROWS][COLS];
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
    
    cout &lt;&lt; "Матриця A =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt; A[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    
    cout &lt;&lt; "Матриця B =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt; B[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    
    cout &lt;&lt; "Матриця C = A + B =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt; C[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>Прокомментируем только несколько ключевых моментов: цикл&nbsp;<code><strong>for </strong>(<strong>int </strong>i = 0; i &lt; ROWS; i++)</code> - перебирает все строки матрицы (его можно читать &quot;для каждой строки <code>i</code>&quot;), а цикл&nbsp;<code><strong>for </strong>(<strong>int </strong>j = 0; j &lt; COLS; j++)</code> - перебирает все столбцы матрицы (&quot;для каждого столбца <code>j</code>&quot;). Чтобы добраться до конкретного элемента матрицы, нам нужны вложенные циклы по переменным <code>i</code> и <code>j</code>, после чего мы можем указать элемент матрицы <code>A</code> с индексами <code>i</code> и <code>j</code> как <code>A[i][j]</code>. Напомню, что функция <code>rand()</code> возвращает число от <code>0</code> до&nbsp;<code>RAND_MAX</code>, после того, как мы берем остаток от деления на 21 мы получаем число от <code>0</code> до <code>20</code>, а после прибавления числа <code>-10</code> мы получаем диапазон от <code>-10</code> до <code>10</code>.</p>

<p>При выводе после каждого числа матрицы я ставлю пробел (например, <code>cout &lt;&lt; A[i][j] &lt;&lt; &quot; &quot;;</code>), но перевожу строку только после вывода всей строки, т.е. после окончания цикла по <code>j</code>, который переберет элементы <code>i</code>-той строки.</p>

<p>Данная программа напечатает:</p>

<pre>
<code class="language-no-highlight">Матрица A =
-9 -6 -1 9 
-2 0 0 -1 
5 0 -8 9 
10 -6 10 -3 
-7 5 6 6 
Матрица B =
7 4 2 -1 
-8 -5 -5 3 
-9 9 -5 -10 
-7 2 7 -1 
-9 -3 6 6 
Матрица C = A + B =
-2 -2 1 8 
-10 -5 -5 2 
-4 9 -13 -1 
3 -4 17 -4 
-16 2 12 12 


</code></pre>

<p>Здесь мы видим, что сумма подсчитана верно, но это проверить не так то просто потому что матрицы напечатаны неровно, а пошли вкривь и вкось. Чтобы поправить данную проблему, нужно использовать стандартную ширину столбца матрицы (чтобы все столбцы имели одинаковую фиксированную ширину, которая достаточна для записи любого элемента матрицы). В данном случае можно взять ширину 3 символа. Кроме того, наша программа при каждом запуске будет выдавать именно приведенный выше&nbsp;ответ. Хотя числа кажутся случайными, но таковыми они не являются. Дело в том, что функция <code>rand()</code> выдает просто одну очень длинную, но вполне фиксированную последовательность, получаемую по некоторым формулам. Такая последовательность называется псевдо-случайной в том смысле, что она похожа по виду и свойствам на случайные числа, но получается по некоторому закону. Для того, чтобы получать каждый раз случайные числа, нужно установить начальное значение генератора псевдо-случайных чисел на некоторый номер элемента последовательности таким образом, чтобы каждый раз данная последовательность начиналась с разного места. Например, текущее время, получаемое при помощи функции <code>time</code> может быть таким начальным номером (который называют <em>зерном</em> - <em>seed</em>). Таким образом, в начале функции <code>main</code> обычно выполняют код <code>srand(time(NULL))</code>&nbsp;(верно и для С и C++) или <code>srand(time(0))</code>&nbsp;(только в языке C++),&nbsp;чтобы инициализировать псевдослучайные числа. Функция <code>srand</code> принимает один параметр, который получается вызовом функции <code>time</code> (которой нужно передать нулевой указатель в качестве параметра). Ниже приведен код, все добавленные или модифицированные строки по сравнению с предыдущей версией которого отмечены комментарием.</p>

<pre>
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;

int main()
{
    srand (time(0)); //ініціалізуємо генератор випадкових чисел на початку програми
    
    const int ROWS = 5, COLS = 4;
    
    int A[ROWS][COLS], B[ROWS][COLS];
    
    const int min = -10, max = 10; //додали дві іменовані константи
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            A[i][j] = min + rand() % (max-min+1);  //використовуємо формулу загального вигляду
        }
    }
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            B[i][j] = min + rand() % (max-min+1);  //використовуємо формулу загального вигляду
        }
    }
    
    int C[ROWS][COLS];
    
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            C[i][j] = A[i][j] + B[i][j]; 
        }
    }
    
    cout &lt;&lt; "Матриця A =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt;setw(3) &lt;&lt; A[i][j] &lt;&lt; " "; //за рахунок маніпулятора setw акуратно виводимо матрицю
        }
        cout &lt;&lt; endl;
    }
    
    cout &lt;&lt; "Матриця B =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt;setw(3) &lt;&lt; B[i][j] &lt;&lt; " "; //за рахунок маніпулятора setw акуратно виводимо матрицю
        }
        cout &lt;&lt; endl;
    }
    
    cout &lt;&lt; "Матриця C = A + B =" &lt;&lt; endl;
    for (int i = 0; i &lt; ROWS; i++)
    {
        for (int j = 0; j &lt; COLS; j++)
        {
            cout &lt;&lt;setw(3) &lt;&lt; C[i][j] &lt;&lt; " "; //за рахунок маніпулятора setw акуратно виводимо матрицю
        }
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>

<p>В коде введены константы <code>min</code> и <code>max</code> для диапазона случайных чисел, которые генерируются теперь по общей формуле <code>min + rand() % (max-min+1)</code>. Действительно,&nbsp; число, полученное по формуле&nbsp;<code>rand() % (max-min+1)</code> лежит в диапазоне от <code>0</code> до <code>max-min</code>&nbsp;(включительно).&nbsp;После добавления к нему числа min получаем искомый диапазон от <code>min</code> до <code>max</code> (включительно).&nbsp;Манипулятор <code>setw(3)</code> обеспечивает выравнивание чисел по правому краю в поле из 3 символов, результат этого выглядит так:</p>

<pre>
<code class="language-no-highlight">Матрица A =
 10   0  -5   9 
  7  -4  -3   0 
  0   5 -10  -3 
  8   0  10  -7 
 10  -6   2   2 
Матрица B =
  7  -4   2 -10 
 -5   5  -1   5 
  5  -7 -10   3 
  1  -5  -1  -3 
  2   6   6  10 
Матрица C = A + B =
 17  -4  -3  -1 
  2   1  -4   5 
  5  -2 -20   0 
  9  -5   9 -10 
 12   0   8  12 


</code></pre>

<p>За счет выполнения строки&nbsp;<code>srand(time(0))</code> мы получили другие числа, и после ещё одного выполнения Вы можете получить совсем другие числа. Проверить это можно здесь:&nbsp;<a href="https://onlinegdb.com/BywuEqYB_" rel="noopener noreferrer nofollow">https://onlinegdb.com/BywuEqYB_</a>. Каждый раз запуская программу заново, Вы будете получать разные числа (а не те, что указаны выше).</p>
