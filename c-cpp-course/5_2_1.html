<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h1>Використання циклу for для контейнерів</h1>

<p>Оскільки елементів контейнера багато, для доступу до них зазвичай використовують оператори циклу. Оператори циклу дозволяють записати певну дію над елементами контейнера у тілі циклу й вказати, що цю дію потрібно застосувати до <em>кожного елемента</em> контейнера. Найзручніше для цього використовувати цикл <strong>for</strong>.</p>

<p>У мові Сі та у старій версії мови C++ — стандарті C++98 — був лише один цикл <strong>for</strong>, який докладно розглядався у попередньому розділі курсу. Для контейнерів із довільним доступом до елементів, наприклад, для масивів, як керуючу змінну циклу часто використовують цілу змінну, що позначає індекс елемента (традиційно використовується ім’я змінної <code>i</code>). У цьому випадку, якщо ми маємо масив <code>arr</code> розміру <code>n</code>, цикл зазвичай записується так:</p>

<pre><code class="language-cpp">for (int i = 0; i &lt; n; i++)
{
    // обробляємо елемент arr[i]
}</code></pre>

<p>Наприклад, для виведення на екран елементів масиву <code>arr</code> розміру <code>n</code> в один рядок можна використати такий код:</p>

<pre><code class="language-cpp">for (int i = 0; i &lt; n; i++)
{
    cout &lt;&lt; arr[i] &lt;&lt; " ";
}
cout &lt;&lt; endl;</code></pre>

<p>У цього коду є невеликий недолік — після кожного елемента масиву виводиться пробіл, навіть після останнього елемента — перед переходом на новий рядок. Але цей останній пробіл не потрібен. Проте на екрані цей пробіл майже непомітний, тому зазвичай на цей недолік не звертають уваги. Його ігнорують навіть автоматизовані системи тестування, у тому числі система тестування на цьому курсі, які не зважають на зайві пробіли в кінці рядків або зайві переходи на новий рядок у кінці виводу. Якщо ж ви хочете позбутися цього недоліку, це можна зробити, наприклад, так:</p>

<pre><code class="language-cpp">for (int i = 0; i &lt; n; i++)
{
    cout &lt;&lt; arr[i];
    if (i + 1 != n)
    {
        cout &lt;&lt; " ";
    }
}
cout &lt;&lt; endl;</code></pre>

<p>У наведених вище фрагментах є і певний стилістичний недолік — для задання розміру контейнера використовується окрема від контейнера змінна <code>n</code>. Як ви дізнаєтеся далі, масиви мови Сі часто задаються вказівником на перший елемент (тобто адресою комірки пам’яті, де зберігається елемент з індексом 0) — і в такому випадку, очевидно, ця адреса не містить інформації про кількість елементів у масиві. У цьому випадку необхідно використовувати окрему змінну або константу, що задає розмір масиву. Але якщо використовується контейнерний клас мови C++, такий як <code>vector</code>, <code>array</code> чи <code>deque</code>, то до об’єкта-контейнера можна застосувати метод <code>size()</code>, який повертає розмір контейнера. Використовується запис: ім’я об’єкта, крапка, ім’я методу і в дужках параметри методу. Оскільки у методу <code>size</code> немає параметрів (від імені самого контейнера викликається метод, тому він не є явним параметром методу і не пишеться у дужках) — дужки залишаються порожніми. У результаті отримуємо такий код:</p>

<pre><code class="language-cpp">for (int i = 0; i &lt; arr.size(); i++)
{
    // обробляємо елемент arr[i]
}</code></pre>

<p>У нових версіях C++ (починаючи з C++17) також можна використовувати функцію <code>size</code> (повна назва <code>std::size</code>) замість методу <code>size</code>. Вона працює по суті так само, лише застосовується не тільки до контейнерних класів, а й до звичайних масивів мови Сі (але не до динамічних масивів мови Сі).</p>

<pre><code class="language-cpp">for (int i = 0; i &lt; std::size(arr); i++)
{
    // обробляємо елемент arr[i]
}</code></pre>

<p>Як бачите, <code>arr</code> перетворюється на параметр функції. Нагадаю, що <code>std::</code> можна не писати, якщо використовується конструкція <code><strong>using namespace </strong>std;</code></p>

<p>Правда, такий звичний багатьом програмістам на C++ код, хоч і компілюється, але викликає попередження — про те, що здійснюється порівняння знакового та беззнакового числа. Давайте розберемось чому. Справа в тому, що як метод <code>size</code>, так і функція <code>std::size</code> повертають значення беззнакового типу <code>size_t</code>, а не типу <strong><code>int</code></strong>.</p>