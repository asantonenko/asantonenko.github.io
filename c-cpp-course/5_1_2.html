<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h1>Масиви</h1>

<p>Традиційно першим типом контейнерів, що використовувалися в програмуванні, були масиви. Масив характеризується тим, що для доступу до конкретного елемента масиву використовується ім’я масиву та номер елемента, який також називається <em>індексом</em>. На відміну від математики та деяких інших мов, наприклад, Pascal, нумерація елементів у мовах C/C++ завжди починається з нуля.</p>

<p>Для звернення до елемента за індексом використовується операція квадратних дужок. Вона має наступний синтаксис:</p>

<p><code><em>ім'я_контейнера</em>[<em>індекс</em>]</code></p>

<p>Наприклад, перший елемент масиву arr можна записати як <code>arr[0]</code>, а другий — як <code>arr[1]</code>.</p>

<p>Контейнери, до яких можна ефективно застосувати доступ до елемента за індексом, називаються контейнерами довільного доступу.</p>

<p>Ми будемо використовувати контейнер <code>vector</code> (динамічний масив C++) у наших прикладах, як один із найпростіших і найчастіше використовуваних контейнерів. Для того, щоб його використати, необхідно підключити заголовний файл vector. Далі вектор можна оголосити так:</p>

<pre><code class="language-cpp">vector&lt;int&gt;    vec1;    //Порожній вектор цілих чисел
vector&lt;double&gt; vec2;    //Порожній вектор дійсних чисел
vector&lt;int&gt;    vec3(5); //Вектор з 5-ти цілих нулів
vector&lt;double&gt; vec4(7); //Вектор з 7-ми дійсних нулів
vector&lt;bool&gt;   vec5(8); //Вектор з 8-ми логічних значень, спочатку рівних false
vector&lt;int&gt;    vec6(10,5); //Вектор з 10-ти п’ятірок
vector&lt;int&gt; vec7 = {1,2,3,1}; //Вектор із вказаних елементів, працює починаючи з C++11
</code></pre>

<p>Якщо не вказати жодних додаткових даних, отримаємо порожній вектор (з нульовою кількістю елементів), як у випадку з <code>vec1</code> та <code>vec2</code>. Якщо в круглих дужках вказати один параметр, він визначає початковий розмір вектора, причому всі елементи будуть проініціалізовані нулями (або порожніми рядками/нульовими вказівниками/порожніми контейнерами/значеннями <strong>false</strong> — тобто, нульовими значеннями відповідного типу). Якщо вказати два параметри у дужках, перший визначає кількість елементів, а другий — початкове значення цих елементів. У випадку <code>vec6</code> тип елементів — <code><strong>int</strong></code>, кількість — <code>10</code>, а самі елементи дорівнюють <code>5</code>. Починаючи зі стандарту C++11, можна вказувати перелік елементів у фігурних дужках, причому знак <code>=</code> у записі 7-го рядка не обов’язковий — вона працюватиме й без нього.</p>

<p>Коректними будуть такі присвоювання:</p>

<pre><code class="language-cpp">vec3[0] = 1;  //Перший елемент вектора vec3 тепер дорівнює 1
vec3[1] = -1; //Наступний елемент вектора vec3 тепер дорівнює -1
vec5[0] = true; //Перший елемент вектора vec5 тепер дорівнює true
vec6[9] = 7;  //Останній елемент вектора vec6 тепер дорівнює 7</code></pre>

<p>Зверніть увагу, що ці присвоювання записувалися б точно так само, якби <code>vec3</code>, <code>vec5</code> і <code>vec6</code> були контейнерами типу <code>deque</code> або звичайними масивами у стилі мови C.</p>

<p>Але наступні присвоювання будуть некоректними:</p>

<pre><code class="language-cpp">vec1[0] = 1;  //У vec1 взагалі немає елементів
vec3[-1] = 1; //Не може існувати елемента з індексом -1
vec5[1000] = true; //У векторі vec5 лише 8 логічних елементів (індекси від 0 до 7)
vec6[10] = 7;  //Останній елемент вектора vec6 має індекс 9, а не 10</code></pre>

<p>На жаль, виконання подібних операторів не призведе навіть до помилки компіляції або виконання — цілком можливо, помилки не буде зовсім. Це добре? Ні, це погано, оскільки буде пошкоджена пам’ять, яка не належить векторами <code>vec1</code>, <code>vec3</code>, <code>vec5</code>, <code>vec6</code>. Це може призвести до важковідтворюваних помилок, які можуть бути виявлені вже на етапі експлуатації програми й спричинити абсолютно неочікувані ефекти. Така ситуація в мовах C/C++ називається невизначеною поведінкою (UB, undefined behavior), і її, звичайно, треба уникати.</p>

<p>Отже, операція <code>[]</code> дозволяє доступ до елемента вектора за індексом без перевірки виходу за межі вектора. Метод <code>at</code> виконує таку перевірку та породжує виняток <code>out_of_range</code> (помилку виконання) у разі виходу за межі вектора. Наприклад, таке виключення згенерує наступний код:</p>

<pre><code class="language-cpp">vec1.at(0) = 1;  //У vec1 взагалі немає елементів
vec3.at(-1) = 1; //Не може існувати елемента з індексом -1
vec5.at(1000) = true; //У векторі vec5 лише 8 логічних елементів (індекси від 0 до 7)
vec6.at(10) = 7;  //Останній елемент вектора vec6 має індекс 9, а не 10</code></pre>

<p>Чому б завжди не використовувати метод <code>at</code>? На жаль, метод <code>at</code> працює повільніше, ніж операція <code>[]</code>, тому, якщо ви впевнені, що індекс не може бути поза допустимим діапазоном, використовуйте операцію <code>[]</code>.</p>