<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h2>Динамическое выделение и освобождение памяти в языке Си</h2>

<p>Для выделения, перевыделения и освобождения памяти в языке Си используются функции:</p>

<pre><code class="language-cpp">void* malloc (size_t size);
void* calloc (size_t num, size_t size);
void* realloc (void* ptr, size_t size);
void free (void* ptr);</code></pre>

<p>Самая простая из функций выделения памяти - функция <code>malloc</code>. Ей нужно указать, сколько байт хотим выделить (параметр <code>size</code>) и она вернет указатель на (только что) выделенную в куче область памяти размером <code>size</code>. При этом вернется нетипизированный указатель, который необходимо будет преобразовать в нужный тип. Таким образом, можно выделить как место под переменную обычного (втроенного) типа, так и под массив, структуру или даже массив структур. Таким же образом можно выделить данные под строку в стиле Си (массив символов):</p>

<pre><code>int * pi   = (int*) malloc(sizeof(int)); //выделили память под int
int * parr = (int*) malloc(5*sizeof(int)); //выделили память под массив из 5 целых чисел
struct Point //структура языка Си, описывает точку на плоскости
{
   double x;
   double y;
};
struct Point * pst    = (struct Point*) malloc(sizeof(struct Point)); //выделили память структуру
struct Point * pstarr = (struct Point*) malloc(10*sizeof(struct Point)); 
//выделили память под массив из 10 структур типа точка

char * str = (char*) malloc(20+1); //выделяем память под 20 символов + ноль символ</code></pre>

<p>Заметим, что выделение памяти под массив практически мало чем отличается от выделения памяти под один элемент данного типа. Более того, можно сказать, что динамически выделенный массив размера один и динамически выделенная память под один элемент - это одно и то же. После выделения памяти функцией <code>malloc</code> в ней находится мусор (т.е. те данные, что там находились ранее). Если выделение памяти при помощи <code>malloc</code> оканчивается неудачей, то возвращается нулевой указатель.</p>

<p>Функция <code>calloc</code> работает аналогично <code>malloc</code>, но дополнительно явно задается количество элементов (таким образом, выделяется <code>num*size</code> байт памяти). Также функция <code>calloc</code>, в отличии от <code>malloc</code>, заполняет выделенную память нулевыми байтами (соответственно, получаются целые или вещественные нули, нулевые указатели и т.д.). Перепишем прошлый пример при помощи функции <code>calloc</code>:</p>

<pre><code>int * pi   = (int*) calloc(1,sizeof(int)); //выделили память под int
int * parr = (int*) calloc(5,sizeof(int)); //выделили память под массив из 5 целых чисел
struct Point //структура языка Си, описывает точку на плоскости
{
   double x;
   double y;
};
struct Point * pst    = (struct Point*) calloc(1,sizeof(struct Point)); //выделили память структуру
struct Point * pstarr = (struct Point*) calloc(10,sizeof(struct Point)); 
//выделили память под массив из 10 структур типа точка

char * str = (char*) сalloc(20+1,1); //выделяем память под 20 символов + ноль символ
//можно и    (char*) сalloc(20+1,sizeof(char)); но в типичной ситуации sizeof(char) == 1</code></pre>

<p>Когда память не нужна, в языке Си её обязательно освободить при помощи функции <code>free</code>. Функции <code>free</code> нужно передать указатель на освобождаемую область, размер освобождаемой области (установленный при помощи <code>malloc</code>, <code>calloc</code> или <code>realloc</code>) функция <code>free</code> определит самостоятельно. Единственное исключение, когда можно не вызывать функцию <code>free</code> - если выделенная область должна использоваться до конца работы программы, тогда перед оператором <code><strong>return</strong> 0;</code>  в функции <code>main</code> не обязательно вызывать функцию <code>free</code>, так как вся память всё равно будет освобождена при выходе из программы.</p>

<p><strong>Пример</strong>: Выделенную выше память можно освободить при помощи:</p>

<pre><code>free(pi);
free(parr);
free(pst);
free(pstarr);
free(str);</code></pre>

<p>Заметим, что функция <code>free</code> не очищает память, и уж тем более не обнуляет указатель. Если Вы хотите защититься от возможности использовать данные после освобождения памяти, можно вручную обнулить указатели:</p>

<pre><code>free(pi); pi = NULL;
free(parr); parr = NULL;
free(pst); pst = NULL;
free(pstarr); pstarr = NULL;
free(str); str = NULL;</code></pre>