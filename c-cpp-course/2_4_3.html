<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>
 <script type="text/javascript" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
 </script>

<h2>Локальні та глобальні змінні</h2>

<p>Усі змінні можна поділити на глобальні та локальні. Глобальними будуть оголошення змінних, записані поза усіма блоками. Локальними змінними будуть змінні, оголошені в деякому блоці - наприклад, всередині функції <code>main</code>. Трохи випередимо матеріал і розглянемо наступний код:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int limit = 15;

int sqr (int x)
{
   int y = x * x;
   return y;
}

int main()
{
   for (int i = 0; i &lt;= limit; i++)
   {
       cout &lt;&lt; i &lt;&lt; " в квадрате равно" &lt;&lt; sqr(i) &lt;&lt;endl;
   }
   return 0;
}</code></pre>

<p>Не хвилюйтеся, якщо ви поки не зовсім розумієте, що відбувається. Не пояснюючи деталі цього коду, скажу, що в ньому оголошено функцію <code>sqr</code> з параметром <code>x</code>, яка обчислює та повертає квадрат свого параметра - за своєю суттю, вона є аналогом стандартних математичних функцій C/C++ <code>sqrt</code>(квадратний корінь), <code>sin</code>, <code>cos</code> а також функція <code>main</code>, в якій деяка змінна <code>i</code> змінюється у циклі від <code>0</code> до значення змінної <code>limit</code> і при цьому друкуються значення змінної <code>i</code> та їх квадрати.</p>

<p>Отже, змінна <code>limit</code> оголошена глобально і буде доступна у всій програмі (і в функції <code>sqr</code>, хоч вона там і не використовується, і в функції <code>main</code>). Змінна <code>y</code> оголошена всередині функції <code>sqr</code> - і тому є локальною в ній. Її час існування обмежений часом роботи функції <code>sqr</code>, вона створюється, коли виконання функції доходить до рядка з її оголошенням, і знищується після виходу з функції. Формальний параметр <code>x</code> функції <code>sqr</code> теж є локальним у цій функції. Ну і нарешті, змінна <code>i</code> є локальною у циклі <code><strong>for</strong></code>, де вона оголошена. Вона існує лише до кінця роботи циклу, і після циклу її вже не буде існувати, тому цей фрагмент міститиме помилку:</p>

<pre><code class="language-cpp">int main()
{
   for (int i = 0; i &lt;= limit; i++)
   {
       cout &lt;&lt; i &lt;&lt; " в квадрате равно" &lt;&lt; sqr(i) &lt;&lt; endl;
   }
   cout &lt;&lt; "После цикла i=" &lt;&lt; i &lt;&lt; endl; //помилка, тут i вже не існує
   return 0;
}</code></pre>

<p><em>Правило гарного стилю</em> говорить про те, що змінні мають бути настільки локальними, наскільки це можливо - тобто, наприклад, змінна, локальна у циклі, який знаходиться всередині функції, краща, ніж змінна, локальна всередині цієї функції - але лише у тому випадку, якщо це можливо за логікою програми.</p>

<p>Глобальних змінних взагалі слід, по можливості, уникати. Оскільки в цьому випадку доступ до неї можливий з будь-якої ділянки коду, то якийсь програміст може помилково її пошкодити. У цьому прикладі використання глобальної змінної <code>limit</code> не виправдане, її можна перенести на початок функції <code>main</code>, і, оскільки ми взагалі не змінюємо її значення, та й не повинні за логікою програми змінювати, можна перетворити її на константу, додавши модифікатор <code><strong>const</strong></code>. Отримаємо наступний код: </p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int sqr (int x)
{
   return x * x;
}

int main()
{
   const int limit = 15;
   for (int i = 0; i &lt;= limit; i++)
   {
       cout &lt;&lt; i &lt;&lt; " в квадрате равно" &lt;&lt; sqr(i) &lt;&lt; endl;
   }
   return 0;
}</code></pre>

<p>Заодно я позбувся змінної <code>y</code>, повернувши значення функції <code>sqr</code> за допомогою одного оператора <code><strong>return</strong></code>. Ці зміни покращують стиль програмування, хоча не впливають на функціонування програми і, швидше за все, не впливають або дуже мало впливають на швидкість її роботи. </p>

<p>Звісно, у цьому прикладі можна позбутися і функції <code>sqr</code>, і константи <code>limit</code>, написавши так:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
   for (int i = 0; i &lt;= 15; i++)
   {
       cout &lt;&lt; i &lt;&lt; " в квадрате равно" &lt;&lt; i*i &lt;&lt; endl;
   }
   return 0;
}</code></pre>

<p>Це скоротить та спростить програму, але це вже не буде таким очевидним покращенням, як раніше. Справа в тому, що функція <code>sqr</code> може знадобититись і в іншому коді, і, взагалі, оголосивши цю функцію, ми явніше показали, що хочемо обчислювати саме квадрати чисел. Тим паче, константа <code>limit</code>, рівна <code>15</code>, набагато чіткіше вказує наші задуми, що нам потрібно друкувати числа до певної межі. При внесенні змін, наприклад, якщо нам захочеться, щоб максимальне число, для якого ми побачимо квадрат, було введено з клавіатури, програму буде простіше виправити, переробивши <code>limit</code> з константи на змінну і ввівши її з клавіатури, ніж якби ми змушені були усі місця, де зустрічається число <code>15</code>, заміняти на змінну <code>limit</code> (у цій програмі це лише одне місце, а у великій і складній програмі?)</p>

<p>Звичайно,  писати весь програмний код у функції <code>main</code> привабливо для невеликих програм, але абсолютно незручно і неприйнятно для великих програм.</p>

<p>Відзначимо, що у мові Сі не завжди вдається уникнути використання глобальних змінних, тоді як у мові C++ завдяки більшій різноманітності мовних засобів майже завжди можливо уникнути використання глобальних змінних. </p>