<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>
 <script type="text/javascript" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
 </script>

<h1>Контейнер map - ассоциативный массив.</h1>

<p>Возможности обычных массивов ограничены в том смысле, что их индексами могут быть только целые числа. Более того, в языках C/C++ индексы всегда начинаются с нуля и идут подряд. А вот если мы захотим, чтобы индексами были не числа, а более сложные объекты. Например, нам задана последовательность некоторых значений некоторого типа и нам нужно посчитать сколько каждый из них встречается. В языке Си есть разве что такая лазейка - индексом в массиве могут быть символы. Это верно, так как символы с точки зрения языка Си являются числами (в C и C++ не различается символ и его код). Поэтому тип char можно использовать в качестве индекса. Впрочем char может быть знаковым типом, а отрицательных индексов не может быть, поэтому лучше использовать unsigned char, впрочем для символов кодировки ASCII это не важно, так как коды символов в этой кодировке от 0 до 127, и в любом случае эти коды будут неотрицательны. Приведем программу вначале на языке Си, в котором строку можно хранить в виде массива символов, при этом символ с кодом 0 обозначает конец строки (нуль-терминированная строка, англ. null terminated string).</p>

<pre><code class="language-cpp">char str[1000]; //строка максимум на 999 символов + терминирующий ноль-символ

gets(str); //читаем строку с клавиатуры

int count_sym[128] = {0}; //массив с количествами символов (только для ASCII символов)

for (int i=0; str[i]; i++)
{
    count_sym[str[i]]++; //для простоты считаем, что только ASCII символы встретятся
}</code></pre>

<p>Немного прокомментирую этот код. Создан массив на 128 символов, так как для простоты мы считаем, что нам встретятся только ASCII символы (не будет русских, греческих букв, псевдографики и прочего). По массиву идем, пока не встретим ноль символ, при этом считаем, что мы его обязательно встретим. Условие, что символ не нулевой можно записать <code>str[i] != 0</code> или <code>str[i] != '\0'</code>, где  <code>'\0'</code> как раз и представляет ноль символ, но это условие можно более кратко записать <code>str[i]</code> (это вполне в стиле языка Си). Символ <code>str[i]</code> используется как индекс в массиве, но не будем забывать, что ASCII-символ, это по сути число от 0 до 127, поэтому код корректен (если будут встречаться только ASCII-символы).</p>

<p>На языке C++ программу можно переписать чуть проще:  </p>

<pre><code class="language-cpp">string str; //C++ строка - длина не ограничена

getline(cin, str); //читаем строку с клавиатуры

int count_sym[128] = {0}; //массив с количествами символов (только для ASCII символов)

for (char ch : str) //перебираем все символы строки
{
    count_sym[ch]++; //для простоты считаем, что только ASCII символы встретятся
}</code></pre>

<p>Теперь представим себе такую ситуацию у нас есть вектор <code>vector&lt;string&gt; words;</code>, который содержит все слова в тексте и мы хотим посчитать сколько встретилось каждое слово. В таком случае нужно использовать в качестве индекса строку. В этом случае уже нельзя использовать обычный массив, и в случае языка Си все очень грустно - либо нужно вручную реализовывать достаточно сложную структуру данных, либо воспользоваться сторонней библиотекой. В случае C++ эту задачу решает контейнер типа ассоциативный массив.</p>

<p><strong>Синтаксис:</strong></p>

<p><code>#include &lt;map&gt;</code></p>

<p><code>map&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt; <em>имя_контейнера</em>;</code></p>

<p>Контейнер ассоциативный массив <code>map&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;</code> внутри себя содержит пары ключ - значение, при этом ключ (первый элемент пары) имеет тип <code><em>тип_ключа</em></code>, а значение - <code><em>тип_значения</em></code>. Например, контейнер <code>map&lt;string,int&gt;</code> будет содержать пары, в которых ключом будет строка, а значением - целое число. Пары реализованы при помощи шаблонного типа <code>pair&lt;<em>тип1</em>, <em>тип2</em>&gt;</code>, который является структурой из двух полей - в поле <code>first</code> храниться первый элемент пары (типа <code><em>тип1</em></code>), а в поле <code>second</code> - второй элемент (типа <code><em>тип2</em></code>),. Например, пара <code>pair&lt;string,int&gt; p;</code> содержит внутри себя два элемента <code>p.first</code> типа <code>string</code> и <code>p.second</code> типа <code>int</code>. Используя шаблонный тип <code>pair</code> мы можем реализовать контейнеры <code>vector&lt;pair&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;&gt;</code> и даже <code>set&lt;pair&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;&gt;</code>. На первый взгляд данные контейнеры тоже содержат пары элементов и мы можем считать первый элемент пар ключом, а второй - значением. Но все равно той функциональности, которую даёт <code>map&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;</code>, нам не даст ни <code>vector&lt;pair&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;&gt;</code>, ни <code>set&lt;pair&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt;&gt;</code>. Давайте как раз разберемся, что нам даёт ассоциативный массив.</p>

<p>В ассоциативном массиве основная операция - это найти и вернуть значение, которое соответствует некоторому заданному ключу. Здесь прямая аналогия с массивом - в котором основная операция - найти и вернуть элемент по индексу. Ещё более явной аналогия становится, так как в ассоциативном массиве используется та же самая операция <code>[]</code> (квадратные скобки), только перегруженная. Напомню, что операция называется перегруженной, если она реализована для какого-то другого типа, кроме того, для которого она изначально была предназначена.</p>

<p>Итак, если есть объявление <code>map&lt;<em>тип_ключа</em>, <em>тип_значения</em>&gt; <em>имя_ассоциативного_массива</em>;</code>, то запись <code><em>имя_ассоциативного_массива</em>[<em>ключ</em>]</code> обозначает обращение к элементу ассоциативного массива <code><em>имя_ассоциативного_массива</em></code> со значения ключа <code><em>ключ</em></code>.  Причем обращение происходит по ссылке, то есть <code><em>имя_ассоциативного_массива</em>[<em>ключ</em>]</code> обозначает именно значение, соответствующее ключу <code><em>ключ</em></code> и лежащее в ассоциативном массиве, а не его копию. Это значение можно не только записать в другую переменную или вывести на экран, а и присвоить при помощи <code><em>имя_ассоциативного_массива</em>[<em>ключ</em>] =  <em>новое_значение</em>;</code> или, например, увеличить на единицу при помощи <code><em>имя_ассоциативного_массива</em>[<em>ключ</em>]++;</code>.</p>

<p>Таким образом наш код, который сколько раз каждое слово вектора <code>words</code> повторяется раз, будет выглядеть так:</p>

<pre><code class="language-cpp">vector&lt;string&gt; words; //некоторый текст

//заполняем переменную words...

map&lt;string, int&gt; count_word; //изначально ассоциативный массив пустой
for (const auto&amp; word : words)
{
    count_word[word]++;
}
</code></pre>

<p>Вот так просто. Так же само, как мы считали символы! Здесь есть некоторое тонкое место:</p>

<p>А что если мы обратимся при помощи операции <code><em>имя_ассоциативного_массива</em>[<em>ключ</em>]</code> к значению с несуществующем в контейнере <code><em>имя_ассоциативного_массива</em></code> ключом? Ответ таков - если пара с ключом равным <code><em>ключ</em></code> не существует, то будет создана пара с ключом <code><em>ключ</em></code> и  значением, которое является значением по умолчанию для типа <code><em>тип_значения</em></code>. Например, если при выполнении операции <code>count_word[word]++;</code> , если слово <code>word</code> ещё не разу не встречалось, то будет создана пара <code>{word, 0}</code> и <code>count_word[word]</code> вернет (по ссылке) нулевое значение, соответствующее ключу <code>word</code>, после чего это значение будет увеличено до 1 при помощи операции <code>++</code>. Собственно, мы этого и хотели. Если же слово <code>word</code> уже встречалось, то <code>count_word[word]</code> вернет его текущее количество (по ссылке), которое будет увеличено операцией  <code>++</code>.</p>

<p>Заметим еще несколько моментов. Изначально, при создании контейнер map будет пустым (это типичное поведение контейнеров языка C++ в случае, если мы не передаём параметров конструктору при создании контейнера). Пары в контейнере будут упорядочены не по порядку добавления элементов в контейнер, а в порядке возрастания ключей. При этом в контейнере <code>map</code> не может быть двух элементов с одинаковым ключом. Естественно, для того, чтобы всё это работало, мы должны уметь сравнивать элементы типа <code><em>тип_ключа</em></code>, по умолчанию используется операция <code>&lt;</code> для этого. В нашем случае <code><em>тип_ключа</em></code> - это строки типа <code>string</code>, поэтому пары будут упорядочены по словам лексикографически (как в словаре). Результат работы программы можно распечатать следующим кодом:</p>

<pre><code class="language-cpp">for (const auto&amp; key_value : count_word)
{
    cout &lt;&lt;"Слово " &lt;&lt;setw(15) &lt;&lt;key_value.first &lt;&lt; " зустрілося " 
         &lt;&lt;setw(15) &lt;&lt;key_value.second &lt;&lt;" разів." &lt;&lt;endl;
}</code></pre>

<p>Починаючи з версії C++17 цей код можна зробити ще більш наочним і зручним так:</p>

<pre><code class="language-cpp">for (const auto&amp; [key, value] : count_word)
{
    cout &lt;&lt;"Слово " &lt;&lt;setw(15) &lt;&lt;key &lt;&lt; " зустрілося " 
         &lt;&lt;setw(15) &lt;&lt;value &lt;&lt;" разів." &lt;&lt;endl;
}</code></pre>

<p>У цьому випадку пара розбивається на складові ключ <code>key</code> і значення <code>value</code> прямо в заголовку циклу.</p>

<p>Перевірити цей код можна тут: <a href="https://onlinegdb.com/pc7hpxV80" rel="noopener noreferrer nofollow">https://onlinegdb.com/pc7hpxV80</a>.  Ця програма підраховує кількість зустрічей кожного із введених слів, до коду вище додано видалення всіх символів пунктуації зі слів. Маніпулятор <code>setw(15)</code> використаний у цій програмі для більш гарного виведення і забезпечує вирівнювання слів і чисел праворуч у полі з 15 символів (правда для слів, записаних кириліцею, в onlineGDB це вирівнювання ламається).</p>