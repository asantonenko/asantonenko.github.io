<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h2>Концепція багатовимірних масивів</h2>

<p>У програмуванні часто використовуються не тільки одномірні масиви, у яких кожен елемент задається комбінацією імені масиву та індексу (наприклад, <code>arr[i]</code>), а й багатовимірні масиви. У них використовується кілька індексів, таким чином, щоб задати конкретний елемент масиву, потрібно задати ім'я масиву та деяку фіксовану кількість індексів (наприклад, <code>arr[i][j][k]</code>).</p>

<p>Найчастіше використовуються двовимірні масиви, які також називають матрицями. Як Ви, напевно, знаєте з лінійної алгебри, числові матриці мають дуже велике значення в математиці, і використовуються для розв'язання систем лінійних рівнянь, завдання лінійних операторів, а також різного виду геометричних перетворень – наприклад, існують матриці повороту на певний кут. Також, якщо ми розглянемо редактори електронних таблиць, такі як Microsoft Excel або Google Spreadsheets, вони по суті теж оперують матрицями. Кожен аркуш такої таблиці є матрицею великого розміру, хіба що елементи комірок такої таблиці можуть мати різні типи на відміну від традиційних двовимірних масивів у програмуванні.</p>

<p>Отже, коли ми говоритимемо про багатовимірні масиви, найчастіше ми використовуватимемо їх двомірну різновид - матриці, які представляють табличні дані. Матриця (таблиця) складається з рядків і стовпців, тому кожен елемент стоїть на перетині деякого рядка і стовпця. Таким чином, щоб задати елемент матриці, нам потрібне її ім'я (наприклад, <code>matr</code>), номер рядка, що містить даний елемент (зазвичай позначається як <code>i</code>) і номер стовпця (зазвичай позначається як <code>j</code>). У мовах C/C++ обидва індекси пишуться кожен у окремих квадратних дужках (а не через кому, на відміну деяких інших мов програмування, наприклад, таких, як Pascal чи C#). Таким чином, отримуємо запис <code>matr[i][j]</code>. Традиційно спочатку пишуть номер рядка, а потім номер стовпця.</p>

<p>Наведемо приклад такої матриці. Спочатку запишемо деякі дані, наприклад, доходи різних підрозділів компанії за кожен місяць деякого року в прямокутну таблицю, як в Excel:</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 1000px;">
	<caption>Доходи підрозділів за 2020 рік</caption>
	<thead>
		<tr>
			<th> </th>
			<th>1. січень</th>
			<th>2. лютий</th>
			<th>3. березень</th>
			<th>4. квітень</th>
			<th>5. травень</th>
			<th>6. червень</th>
			<th>7. липень</th>
			<th>8. серпень</th>
			<th>9. вересень</th>
			<th>10. жовтень</th>
			<th>11. листопад</th>
			<th>12. грудень</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>1. відділ смартфонів</th>
			<td>10.3</td>
			<td>7.1</td>
			<td>5.3</td>
			<td>5.4</td>
			<td>4.1</td>
			<td>5.0</td>
			<td>4.3</td>
			<td>5.7</td>
			<td>8.1</td>
			<td>5.6</td>
			<td>7.3</td>
			<td>11.1</td>
		</tr>
		<tr>
			<th>2. відділ ноутбуків</th>
			<td>7.4</td>
			<td>2.1</td>
			<td>3.1</td>
			<td>2.5</td>
			<td>3.1</td>
			<td>2.8</td>
			<td>1.9</td>
			<td>5.5</td>
			<td>5.4</td>
			<td>1.1</td>
			<td>2.3</td>
			<td>7.1</td>
		</tr>
		<tr>
			<th>3. відділ фототехніки</th>
			<td>3.1</td>
			<td>1.1</td>
			<td>0.5</td>
			<td>0.1</td>
			<td>0.5</td>
			<td>1.1</td>
			<td>1.2</td>
			<td>1.5</td>
			<td>0.7</td>
			<td>1.1</td>
			<td>2.1</td>
			<td>2.2</td>
		</tr>
		<tr>
			<th>4. відділ побутової техніки</th>
			<td>4.1</td>
			<td>3.4</td>
			<td>2.1</td>
			<td>2.1</td>
			<td>0.5</td>
			<td>0.2</td>
			<td>1.1</td>
			<td>2.1</td>
			<td>1.8</td>
			<td>2.0</td>
			<td>1.1</td>
			<td>3.5</td>
		</tr>
	</tbody>
</table>

<p>У яких одиницях задані доходи, можете придумати самі (наприклад, тисячі доларів для невеликої аміріканської компанії чи мільйони гривень, для великого українського магазину чи мережі магазинів – я не експерт у цьому). Зауважимо, що назва самої таблиці та назви стовпців мають зовсім інший тип (рядковий), ніж основні дані (числові), тому їх варто зберігати окремо (у масивах рядків), ми ж зараз розглянемо тільки числові дані:</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 700px;">
	<tbody>
		<tr>
			<td>10.3</td>
			<td>7.1</td>
			<td>5.3</td>
			<td>5.4</td>
			<td>4.1</td>
			<td>5.0</td>
			<td>4.3</td>
			<td>5.7</td>
			<td>8.1</td>
			<td>5.6</td>
			<td>7.3</td>
			<td>11.1</td>
		</tr>
		<tr>
			<td>7.4</td>
			<td>2.1</td>
			<td>3.1</td>
			<td>2.5</td>
			<td>3.1</td>
			<td>2.8</td>
			<td>1.9</td>
			<td>5.5</td>
			<td>5.4</td>
			<td>1.1</td>
			<td>2.3</td>
			<td>7.1</td>
		</tr>
		<tr>
			<td>3.1</td>
			<td>1.1</td>
			<td>0.5</td>
			<td>0.1</td>
			<td>0.5</td>
			<td>1.1</td>
			<td>1.2</td>
			<td>1.5</td>
			<td>0.7</td>
			<td>1.1</td>
			<td>2.1</td>
			<td>2.2</td>
		</tr>
		<tr>
			<td>4.1</td>
			<td>3.4</td>
			<td>2.1</td>
			<td>2.1</td>
			<td>0.5</td>
			<td>0.2</td>
			<td>1.1</td>
			<td>2.1</td>
			<td>1.8</td>
			<td>2.0</td>
			<td>1.1</td>
			<td>3.5</td>
		</tr>
	</tbody>
</table>

<p>Такі дані можна зберегти в прямокутній матриці з елементами дійсного типу розміру 4 рядки на 12 стовпчиків. Нагадаю, що на першому місці вказується кількість рядків, а на другому – кількість стовпчиків. Таку матрицю називатимемо дійсною матрицею розміру 4 на 12.</p>

<h2>Матриці мови Сі</h2>

<p>Синтаксис:</p>

<p><code><em>тип_елементів</em> <em>ім'я_матриці</em>[<em>кількість_рядків</em>][<em>кількість_стовпчиків</em>];</code></p>

<p>або</p>

<p><code><em>тип_елементів</em> <em>ім'я_матриці</em>[<em>кількість_рядків</em>][<em>кількість_стовпчиків</em>] = {<em>список елементів через кому</em>};</code></p>

<p>або</p>

<p><code><em>тип_елементів</em> <em>ім'я_матриці</em>[<em>кількість_рядків</em>][<em>кількість_стовпчиків</em>] = </code></p>

<p><code>{{<em>список елементів першого рядка}, </em>{<em>список елементів другого рядка},..., </em>{<em>список елементів останнього рядка}</em>};</code></p>

<p>або </p>

<p><code><em>тип_елементів ім'я_матриці</em>[][<em>кількість_стовпчиків</em>] = </code></p>

<p><code>{{<em>список елементів першого рядка}, </em>{<em>список елементів другого рядка},..., </em>{<em>список елементів останнього рядка}</em>};</code></p>

<p>Таким чином, просто оголосити дійсну матрицю  розміру 4 на 12 можна так:</p>

<pre><code>double revenue[4][12];</code></pre>

<p>У подібній матриці буде сміття. Якщо ми бажаємо заповнити матрицю нулями, можна написати так:</p>

<pre><code class="language-cpp">double revenue[4][12] = {};</code></pre>

<p>Пропущені елементи в ініціалізаторі заповнюються нулями (нульовими елементами). Щоправда у мові Сі для цього треба хоча б один нуль у дужках написати (у мові С++ це необов'язково).</p>

<p>Якщо ми хочемо її заповнити числами з таблиці, наведеної вище, то можна просто перерахувати їх через кому:</p>

<pre><code>double revenue[4][12] =
{ 10.3, 7.1, 5.3, 5.4, 4.1, 5.0, 4.3, 5.7, 8.1, 5.6, 7.3, 11.1,
   7.4, 2.1, 3.1, 2.5, 3.1, 2.8, 1.9, 5.5, 5.4, 1.1, 2.3,  7.1,
   3.1, 1.1, 0.5, 0.1, 0.5, 1.1, 1.2, 1.5, 0.7, 1.1, 2.1,  2.2,
   4.1, 3.4, 2.1, 2.1, 0.5, 0.2, 1.1, 2.1, 1.8, 2.0, 1.1,  3.5 };</code></pre>

<p>але краще окремо виділити кожен рядок матриці: </p>

<pre><code>double revenue[4][12] = 
{ {10.3, 7.1, 5.3, 5.4, 4.1, 5.0, 4.3, 5.7, 8.1, 5.6, 7.3, 11.1},
  { 7.4, 2.1, 3.1, 2.5, 3.1, 2.8, 1.9, 5.5, 5.4, 1.1, 2.3,  7.1},
  { 3.1, 1.1, 0.5, 0.1, 0.5, 1.1, 1.2, 1.5, 0.7, 1.1, 2.1,  2.2},
  { 4.1, 3.4, 2.1, 2.1, 0.5, 0.2, 1.1, 2.1, 1.8, 2.0, 1.1,  3.5} };</code></pre>

<p>Ми навіть можемо попросити компілятор мови C або C++ порахувати кількість рядків матриці за Вас (але не кількість стовпчиків), хоча цією можливістю краще не зловживати: </p>

<pre><code>double revenue[][12] = 
{ {10.3, 7.1, 5.3, 5.4, 4.1, 5.0, 4.3, 5.7, 8.1, 5.6, 7.3, 11.1},
  { 7.4, 2.1, 3.1, 2.5, 3.1, 2.8, 1.9, 5.5, 5.4, 1.1, 2.3,  7.1},
  { 3.1, 1.1, 0.5, 0.1, 0.5, 1.1, 1.2, 1.5, 0.7, 1.1, 2.1,  2.2},
  { 4.1, 3.4, 2.1, 2.1, 0.5, 0.2, 1.1, 2.1, 1.8, 2.0, 1.1,  3.5} };</code></pre>

<p>Якщо в списку ініціалізаторів менше елементів, ніж розмір масиву, то елементи масиву, що залишилися, ініціалізуються нулями (нульовими елементами відповідного типу). Якщо ж число ініціалізаторів більше, ніж потрібно, з'являється повідомлення про помилку. Ці правила застосовуються і до кожного вкладеного списку ініціалізаторів.</p>

<h2>Багатовимірні масиви мови Сі </h2>

<p>Синтаксис:</p>

<p><code><em>тип_элементов</em> <em>имя_массива</em>[<em>размер1</em>][<em>размер2</em>]...[<em>размерN</em>];</code></p>

<p>или</p>

<p><code><em>тип_элементов</em> <em>имя_массива</em>[<em>размер1</em>][<em>размер2</em>]...[<em>размерN</em>] = {<em>список элементов через запятую</em>};</code></p>

<p>или</p>

<p><code><em>тип_элементов</em> <em>имя_массива</em>[<em>размер1</em>][<em>размер2</em>]...[<em>размерN</em>] = {<em>список со вложенными фигурными скобками</em>};</code></p>

<p>или</p>

<p><code><em>тип_элементов</em> <em>имя_массива</em>[][<em>размер2</em>]...[<em>размерN</em>] = {<em>список со вложенными фигурными скобками</em>};</code></p>

<p>Количество индексов в массиве называется <em>размерностью</em> массива и не ограничено по стандарту языков C/C++. При инициализации массива можно опускать только первый размер.</p>

<p><code><em>тип_елементів</em> <em>ім'я_масиву</em>[<em>розмір1</em>][<em>розмір2</em>]...[<em>розмірN</em>];</code></p>

<p>або</p>

<p><code><em>тип_елементів</em> <em>ім'я_масиву</em>[<em>розмір1</em>][<em>розмір2</em>]...[<em>розмірN</em>] = {<em>список елементів через кому</em>};</code></p>

<p>або</p>

<p><code><em>тип_елементів</em> <em>ім'я_масиву</em>[<em>розмір1</em>][<em>розмір2</em>]...[<em>розмірN</em>] = {<em>список із вкладеними фігурними дужками</em>};</code></p>

<p>або</p>

<p><code><em>тип_елементів</em> <em>ім'я_масиву</em>[][<em>розмір2</em>]...[<em>розмірN</em>] = {&lt; em&gt;список із вкладеними фігурними дужками};</code></p>

<p>Кількість індексів у масиві називається <em>розмірністю</em> масиву і вона не обмежена за стандартом мов C/C++. При ініціалізації масиву можна опускати лише перший розмір.</p>