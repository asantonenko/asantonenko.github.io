<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<p><em>Вказівник</em> або покажчик (англ. <em>pointer</em>) &mdash; тип даних, що містить адресу в пам&#39;яті комп&#39;ютера деякої змінної чи об&#39;єкта. Нульова адреса використовується для вказівки того, що в даний момент вказівник не посилається на якісь дані. (див. <a href="https://uk.wikipedia.org/wiki/%D0%92%D0%BA%D0%B0%D0%B7%D1%96%D0%B2%D0%BD%D0%B8%D0%BA" rel="noopener noreferrer nofollow">Вікіпедія Вказівник</a>).</p>

<p>Вказівники присутні у багатьох мовах, явно (як у C/C++ і Pascal) чи неявно (у якості посилальних типів, як у Java). Але саме в мові C вказівники є ключовим мовним засобом, без якого, по суті, неможливо обійтися в серйозних програмах. У мові C++ ситуація трохи цікавіша, звичайні вказівники мови C (які ще називаються <em>сирими вказівниками</em> &mdash; <em>raw pointers</em>) теж є важливим мовним засобом, який використовується &quot;під капотом&quot; найрізноманітніших структур і механізмів мови C++, але у високорівневому програмуванні (тобто створенні прикладних застосунків, а не системних бібліотек) використання сирих вказівників в C++ небажано. Натомість мова C++ надає такі мовні засоби (яких немає в мові C), як <em>посилання</em> та <em>розумні вказівники</em>.</p>

<p>Отже, у цьому уроці ми розглядатимемо лише вказівники у стилі Сі, чи так звані сирі вказівники C++.&nbsp;</p>

<p><strong>Синтаксис:</strong></p>

<p><code><em>тип</em>*</code></p>

<p><code><em>тип</em>* <em>імʼя_змінної</em>;</code></p>

<p>У першому рядку вказано синтаксис опису типу вказівника, а в другому&nbsp;&mdash; оголошення змінної типу вказівник.</p>

<p><strong>Приклад:</strong></p>

<pre>
<code class="language-cpp">int* pi;
double* pd;</code></pre>

<p>Змінна <code>pi</code> може зберігати адресу деякого цілого числа (типу <strong><code>int</code></strong>), а змінна <code>pd</code>&nbsp; &mdash; адресу дійсного числа (типу <code><strong>double</strong></code>).</p>

<p>Цікаво, що для оголошення двох вказівників на елементи одного типу, зірочку потрібно продублювати. Тобто потрібно написати:</p>

<pre>
<code class="language-cpp">int * ptr1, * ptr2;</code></pre>

<p>Якщо ж цього не зробити, то після</p>

<pre>
<code class="language-cpp">int * ptr1, ptr2;</code></pre>

<p>виявиться, що <code>ptr1</code> &mdash; це вказівник на ціле число, а <code>ptr2</code> &mdash; це ціле число (типу <code><strong>int</strong></code>).</p>

<p>У мові Сі це дозволяє описувати різні типи в одному рядку:</p>

<pre>
<code class="language-cpp">int x, *ptr, arr1[10], arr2[40]; 
//x - ціле число
//ptr - вказівник
//arr1, arr2 - масиви</code></pre>

<p>Давайте подумаємо, для вирішення яких завдань взагалі можуть знадобитися вказівники та споріднені з ними засоби, наприклад, посилання. У мові C++ для звичайних типів&nbsp;використовується значуща логіка. Це означає, що якщо ми можемо записати в нову змінну певне значення з уже існуючої, це все ж будуть різні змінні, навіть з однаковим значенням. Тобто, якщо ми запишемо такі оголошення:</p>

<pre>
<code class="language-cpp">int x = 1;
int y = x;</code></pre>

<p>&nbsp;то <code>x</code> та <code>y</code> будуть різними змінними, ніяк не повʼязаними між собою, те саме буде й для &quot;правильних&quot; складніших типів C++, наприклад, <code>string</code> чи <code>vector&lt;<strong>int</strong>&gt;</code>:</p>

<pre>
<code class="language-cpp">string str1 = "!!!";
string str2 = str1;

vector&lt;int&gt; v1 = {1, 2, 3};
vector&lt;int&gt; v2 = v1;</code></pre>

<p>Тут є 4 різні змінні: <code>str1</code>, <code>str2</code>, <code>v1</code>, <code>v2</code>. Якщо ми змінимо змінну, наприклад, <code>str1</code> ось так:&nbsp;</p>

<pre>
<code class="language-cpp">str1[0] = '?';</code></pre>

<p>це ніяк не змінить значення змінної <code>str2</code>.</p>

<p>Це називається значуща семантика.</p>

<p>Якщо тепер ми хочемо звернутися до певної змінної не напряму, через її імʼя, а якимось іншим незалежним способом &mdash; що робити? Можна зробити так: зберегти її адресу в змінну типу вказівник, а при необхідності доступу до значення змінної звертатися до неї через вказівник. Головна перевага тут у тому, що вказівників на одну й ту саму змінну може бути багато, займають вони мало місця й копіюються швидко, на відміну від самої змінної, яка може займати багато памʼяті. Копіювання складних типів може бути повільним або взагалі забороненим у деяких випадках.&nbsp;</p>

<p>Наведемо найпростіший синтетичний приклад. Оголосимо змінну цілого типу та запамʼятаємо її адресу у вказівнику. Після цього до змінної можна звертатися через вказівник:</p>

<pre>
<code class="language-cpp">int x;            //змінна цілого типу
int * px = &amp;x;    //у вказівник поміщаємо адресу змінної
*px = 7;          //присвоюємо значення 7 змінній x через вказівник px
(*px)++;          //збільшуємо змінну x
cout &lt;&lt;*px;       //виводимо значення x
</code></pre>

<p>Пояснюю цей приклад у відео (під час перегляду розгорніть відео на весь екран):</p>

<p><iframe allowfullscreen="" height="315" src="https://www.youtube.com/embed/eNB3WRiyzcg" width="560"></iframe></p>

<p>Відразу скажу, що такий приклад зовсім не показовий, бо ми в одному місці оголошуємо змінну, присвоюємо вказівник і працюємо через нього. Виникає питання: навіщо тут вказівник? Що дає його використання? І справді, у цьому фрагменті вказівник досить марний. Але надалі ви побачите, наскільки потужний і гнучкий це інструмент, і що він дозволяє робити. Також на наступному кроці ми розглянемо&nbsp;трохи більш осмислений приклад.</p>
