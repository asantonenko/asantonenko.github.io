<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>
 <script type="text/javascript" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
 </script>

<p>Операції цілочисленного ділення (<code>/</code>) та остачі від ділення (<code>%</code>) працюють у парі утворюючи процес ділення з остачею:</p>

<p>Ми розбиваємо деяке число <span class="math-tex">\(a\)</span> на частину, яка ділиться на число <span class="math-tex">\(b\)</span> і остачу (частина, що не поділилася на число <span class="math-tex">\(b\)</span>).</p>

<p>Таким чином, отримуємо рівняння <span class="math-tex">\(a = q \cdot b + r\)</span>.</p>

<p>Зазначимо те, що остача від ділення у C/C++ працює не зовсім коректно з математичної точки зору. Справді, у мові С/С++ буде <code>-5 / 2 = -2</code>, а <code>-5 % 2 = -1</code>. Тобто ми отримуватимемо негативну остачу для негативних чисел. Це означає, що використовується ділення з остачею виду <span class="math-tex">\(-5 = 2 \cdot (-2) + (-1)\)</span>, а не <span class="math-tex">\(-5 = 2 \cdot (-3) + 1\)</span>, як має бути.</p>

<p>Давайте розглянемо, до чого це призводить і як із цим боротися. Тут мені потрібно розповісти деяку математичну основу, якщо Вас вона не цікавить, а просто хочете дізнатися, як обчислити позитивний залишок, можете перескочити до останнього абзацу. Операція "остача від ділення" ключова в так званій <em>модульній арифметиці</em>. При обчисленні в подібній арифметиці вибирається деякий базовий модуль <span class="math-tex">\(m\)</span> (часто, але не завжди, просте число) і далі всі числа, що відрізняються на число, кратне  <span class="math-tex">\(m\)</span>  вважаються еквівалентними. Якщо точніше, вони називаються рівними (конгруентними) за модулем <span class="math-tex">\(m\)</span> (позначається <span class="math-tex">\(a \equiv b \pmod{m}\)</span>). Модулярна арифметика застосовується дуже часто - у криптосистемах, у генераторах випадкових чисел, при обчисленні хеш-функцій.</p>

<p>Множина всіх чисел конгруентних з деяким числом <span class="math-tex">\(a\)</span> називається класом лишків <span class="math-tex">\(a\)</span> за модулем <span class="math-tex">\(m\)</span>. У кожному класі лишків усі числа можна конгруентні між собою. Наприклад, множина чисел, конгруентних з одиницею за модулем 10, це <span class="math-tex">\(\{ \dots, -19, -9, 1, 11, 21, 31, 41, \dots \} \)</span> і в цій множині всі числа конгруентні між собою. Справді, перевіримо, що 31 і -19 конгруентні за модулем 10 - що записується як <span class="math-tex">\(31 \equiv -19 \pmod{10}\)</span>. Для цього знайдемо різницю <span class="math-tex">\(31 - (-19) = 50\)</span> і дійсно, 50 ділиться на 10. Клас лишків можна задати будь-яким з його представників, наприклад клас лишків 31 і клас лишків -19 по модулю 10 збігаються з вже наведеним класом лишків 1 по модулю 10. У класі лишків можна вибрати один представник - зазвичай вибирається мінімальне невід'ємне число в класі. Оскільки кожне число завжди конгруентне за модулем <span class="math-tex">\(m\)</span> зі своїм залишком від поділу на <span class="math-tex">\(m\)</ span> (бо <span class="math-tex">\(a = q \cdot m + r\)</span>, звідки <span class="math-tex">\(a - r = q \cdot m\)</span>), щоб отримати даного представника, необхідно просто взяти залишок від розподілу числа на <span class="math-tex">\(m\)</span>. Усього існує <span class="math-tex">\(m\)</span> класів лишків за модулем <span class="math-tex">\(m\)</span> та їх представниками обирають числа <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\ (2\)</span>, ...,  <span class="math-tex">\(m-1\)</span>, які є залишками від ділення.</p>

<p>Наприклад, щоб знайти значення добуток <span class="math-tex">\(a\cdot b\cdot c\)</span> за модулем <span class="math-tex">\(m\)</span>, можна записати арифметичний вираз <code>(a*b*c)%m</code>, але за такого підходу можливе переповнення при обчисленні добутку <code>a*b*c</code>,  краще написати еквівалентний вираз  <code>((a*b)%m*c)%m</code>. Таким чином, основний принцип - для виконання обчислень у модулярній арифметиці застосовувати залишок від поділу не тільки в самому кінці, а під час обчислень теж.</p>

<p>Нагадаю, що суть хеш функції в тому, щоб за вхідною інформацією (вхідним масивом даних) довільної довжини отримати число у фіксованому діапазоні (або фіксована кількість біт). В даному випадку, модулярна арифметика нам дуже навіть може допомогти, оскільки незалежно від розміру вихідних даних при обчисленні за модулем <span class="math-tex">\(m\)</span> ми будемо отримувати одно з чисел  <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span>.</p>

<p>А тепер подивимося, що виходить у разі від'ємних залишків. Допустимо при обчисленні деякої величини за модулем 10 вийде відповідь 21 або 31 або 41 - не важливо, ми беремо залишок і отримує відповідь за модулем 10 - тобто відповідь дорівнює 1. Але якщо ми отримаємо від'ємне число з цього ж класу лишків, наприклад -19, то застосувавши операцію <code>%</code> мови C/C++ ми отримаємо від'ємний залишок <code>-19%10 = -9 </code>. Так, насправді число -9 теж лежить у цьому класі лишків, але ми ж домовилися використовувати тільки числа   <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span> як представників. Наприклад, це дуже важливо для хеш-фукції. А в такій структурі даних як хеш-таблиця значення хеш-функції використовується як індекс масиву, і природно, воно має бути додатнім. Та й взагалі незручно - адже, як перевірити, що ми отримали те саме значення за модулем 10? Коли ми отримуємо нормальні математичні залишки - від  <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span>, то для того, щоб перевірити чи лежать числа в одному класі лишків, можна просто порівняти між собою залишки від ділення на <span class="math-tex">\(m\)</span> - якщо вони рівні, то числа лежать в одному класі (наприклад, хеш-функції збігаються). Але за від'ємних залишків так зробити вже не можна.</p>

<p>Не у всіх мовах операція <code>%</code> працює як у C/C++, видаючи від'ємні залишки. У мові Python реалізована нормальна математична операція "залишок від ділення" (принаймні якщо ділити на додатні числа). Щоб завжди отримувати додатній залишок у мові C/C++ можна написати код:</p>

<pre><code class="language-cpp">int r = a % m;
if (r &lt; 0)
{
    r += m;
}</code></pre>

<p> але це а) досить громіздко б) досить повільно (оператор <strong><code>if</code></strong> виконується повільніше за арифметичні обчислення). Тому діятимемо так: отримаємо залишок від ділення <code>a % m</code> (можливо від'ємний), про всяк випадок додамо <code>m</code> - тепер отримали вже точно невід'ємну величину, але може бути більшу ніж <code>m</code> (якщо залишок був спочатку додатнім) - і потім знову візьмемо залишок від ділення на <code>m</code>. Отримуємо підсумковий вираз для "правильного" залишку від ділення числа <code>a</code> на <code>m</code>:</p>

<pre><code class="language-cpp">((a % m) + m) % m</code></pre>