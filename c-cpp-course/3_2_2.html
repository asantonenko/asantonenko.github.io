<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>
 <script type="text/javascript" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
 </script>

<p>Операції цілочисленного ділення (<code>/</code>) та остачі від ділення (<code>%</code>) працюють у парі утворюючи процес ділення з остачею:</p>

<p>Ми розбиваємо деяке число <span class="math-tex">\(a\)</span> на частину, яка ділиться на число <span class="math-tex">\(b\)</span> і остачу (частина, що не поділилася на число <span class="math-tex">\(b\)</span>).</p>

<p>Таким чином, отримуємо рівняння <span class="math-tex">\(a = q \cdot b + r\)</span>.</p>

<p>Зазначимо те, що остача від ділення у C/C++ працює не зовсім коректно з математичної точки зору. Справді, у мові С/С++ буде <code>-5 / 2 = -2</code>, а <code>-5 % 2 = -1</code>. Тобто ми отримуватимемо негативну остачу для негативних чисел. Це означає, що використовується ділення з остачею виду <span class="math-tex">\(-5 = 2 \cdot (-2) + (-1)\)</span>, а не <span class="math-tex">\(-5 = 2 \cdot (-3) + 1\)</span>, як має бути.</p>

<p>Давайте розглянемо, до чого це призводить і як із цим боротися. Тут мені потрібно розповісти деяку математичну основу, якщо Вас вона не цікавить, а просто хочете дізнатися, як обчислити позитивний залишок, можете перескочити до останнього абзацу. Операція "остача від ділення" ключова в так званій <em>модульній арифметиці</em>. При обчисленні в подібній арифметиці вибирається деякий базовий модуль <span class="math-tex">\(m\)</span> (часто, але не завжди, просте число) і далі всі числа, що відрізняються на число, кратне  <span class="math-tex">\(m\)</span>  вважаються еквівалентними. Якщо точніше, вони називаються рівними (конгруентними) за модулем <span class="math-tex">\(m\)</span> (позначається <span class="math-tex">\(a \equiv b \pmod{m}\)</span>). Модулярна арифметика застосовується дуже часто - у криптосистемах, у генераторах випадкових чисел, при обчисленні хеш-функцій.</p>

<p>Множина всіх чисел конгруентних з деяким числом <span class="math-tex">\(a\)</span> називається класом лишків <span class="math-tex">\(a\)</span> за модулем <span class="math-tex">\(m\)</span>. У кожному класі лишків усі числа можна конгруентні між собою. Наприклад, множина чисел, конгруентних з одиницею за модулем 10, це <span class="math-tex">\(\{ \dots, -19, -9, 1, 11, 21, 31, 41, \dots \} \)</span> і в цій множині всі числа конгруентні між собою. Справді, перевіримо, що 31 і -19 конгруентні за модулем 10 - що записується як <span class="math-tex">\(31 \equiv -19 \pmod{10}\)</span>. Для цього знайдемо різницю <span class="math-tex">\(31 - (-19) = 50\)</span> і дійсно, 50 ділиться на 10. Клас лишків можна задати будь-яким з його представників, наприклад клас лишків 31 і клас лишків -19 по модулю 10 збігаються з вже наведеним класом лишків 1 по модулю 10. У класі лишків можна вибрати один представник - зазвичай вибирається мінімальне невід'ємне число в класі. Оскільки кожне число завжди конгруентне за модулем <span class="math-tex">\(m\)</span> зі своїм залишком від поділу на <span class="math-tex">\(m\)</ span> (бо <span class="math-tex">\(a = q \cdot m + r\)</span>, звідки <span class="math-tex">\(a - r = q \cdot m\)</span>), щоб отримати даного представника, необхідно просто взяти залишок від розподілу числа на <span class="math-tex">\(m\)</span>. Усього існує <span class="math-tex">\(m\)</span> класів лишків за модулем <span class="math-tex">\(m\)</span> та їх представниками обирають числа <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\ (2\)</span>, ...,  <span class="math-tex">\(m-1\)</span>, які є залишками від ділення.</p>

<p>Например, чтобы найти значение произведение <span class="math-tex">\(a\cdot b\cdot c\)</span> по модулю <span class="math-tex">\(m\)</span> , можно записать арифметическое выражение <code>(a*b*c)%m</code>,  но при таком подходе возможно переполнение при вычислении произведения <code>a*b*c</code>,  лучше написать эквивалентное выражение  <code>((a*b)%m*c)%m</code>. Таким образом, основной принцип - для выполнения вычислений в модулярной арифметике применять остаток от деления не только в самом конце, а по ходу вычислений тоже.</p>

<p>Напомню, что суть хэш функции в том, чтобы по входной информации (входному массиву данных) произвольной длины получить число в фиксированном диапазоне (или фиксированное количество бит). В данном случае, модулярная арифметика нам очень даже может помочь, так как вне зависимости от размера исходных данных при вычислении по  модулю <span class="math-tex">\(m\)</span> мы будем получать одно из чисел  <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span> .</p>

<p>А теперь посмотрим, что получается в случае наличия отрицательных остатков. Допустим при вычислении некоторой величины по модулю 10 получится ответ 21 или 31 или 41 - не важно, мы берем остаток и получает ответ по модулю 10 - т.е. ответ, равный 1. Но если мы получим отрицательное число из этого же класса вычетов, например -19, то применив операцию <code>%</code> языка C/C++ мы получим отрицательный остаток <code>-19%10 = -9</code>. Да, число -9 тоже лежит в этом классе вычетов, но мы же договорились использовать только числа   <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span> в качестве представителей. Например, это очень важно для хэш-фукнции. А в такой структуре данных как хэш-таблица значение хэш-функции используется в качестве индекса в массиве, и естественно, оно должно быть положительным. Да и вообще неудобно - ведь, как проверить, что мы получили то же самое значение по модулю 10? Когда мы получаем нормальные математические остатки - от  <span class="math-tex">\(0\)</span>, <span class="math-tex">\(1\)</span>, <span class="math-tex">\(2\)</span>, ...,  <span class="math-tex">\(m-1\)</span> , то для того, чтобы проверить лежат ли числа в одном классе вычетов, можно просто сравнить между собой остатки от деления на <span class="math-tex">\(m\)</span> - если они равны, то числа лежат в одном классе (например, хеш-функции совпадают). Но при отрицательных остатках так сделать уже нельзя.</p>

<p>Не во всех языках операция <code>%</code> работает как в C/C++, выдавая отрицательные остатки. В языке Python реализована нормальная математическая операция "остаток от деления". Чтобы получать всегда положительный остаток в языке C/C++ можно написать код:</p>

<pre><code class="language-cpp">int r = a % m;
if (r &lt; 0)
{
    r += m;
}</code></pre>

<p>но это а) довольно громоздко б) достаточно медленно (оператор <strong><code>if</code></strong> выполняется медленнее арифметических вычислений). Поэтому будем действовать так: получим остаток от деления <code>a % m</code> (возможно отрицательный), на всякий случай добавим <code>m</code> - теперь получили уже точно неотрицательную величину, но может быть большую <code>m</code> (если остаток был изначально положительным) - и затем еще раз возьмем остаток от деления на <code>m</code>. Получаем итоговое выражение для "правильного" остатка от деления числа <code>a</code> на <code>m</code>:</p>

<pre><code class="language-cpp">((a % m) + m) % m</code></pre>