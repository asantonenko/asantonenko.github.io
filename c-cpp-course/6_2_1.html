<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <script>hljs.highlightAll();</script>

<h2>Способи виділення пам&#39;яті</h2>

<p>Отже, у минулому розділі щодо вказівників не зовсім зрозуміло було, навіщо ж вони взагалі потрібні. У цьому уроці ми дізнаємося, що вказівники необхідні реалізації динамічного виділення пам&#39;яті.&nbsp;</p>

<p>Ми знаємо, що для зберігання даних у мовах програмування використовуються змінні. Змінні можна класифікувати за їх типом, зокрема чи є вони об&#39;єктами або даними примітивних типів, крім того, змінні можуть бути локальними або глобальними. Але будь-які дані, з якими працює мови C/C++, можна класифікувати за способом виділення під них пам&#39;яті, а також звільнення пам&#39;яті. Від цього способу роботи з деякими даними (змінними) залежить:</p>

<ol>
	<li>де (в якій галузі) виділяється пам&#39;ять під необхідні дані у програмі;</li>
	<li>коли (коли) виділяється пам&#39;ять (таким чином, у програмі з&#39;являється доступ до даних - зазвичай через змінну);</li>
	<li>коли звільняється пам&#39;ять, таким чином змінна руйнується (знищується, перестає існувати).&nbsp;</li>
</ol>

<p>Мови C і С++ підтримують три основні типи виділення (або розподілу) пам&#39;яті.&nbsp;</p>

<h3>1. Автоматичне виділення пам&#39;яті</h3>

<p>Цей спосіб застосовується за замовчанням для всіх локальних змінних (а також параметрів функцій). У курсі вже згадувалося, що локальну змінну видно тільки в тому блоці, де вона оголошена. Коли ми говоримо про автоматичну змінну, маємо на увазі те, що під неї пам&#39;ять розподіляється автоматично, тобто змінна створюється в момент оголошення (або, точніше, коли виконання дійде до рядка програми, в якій вона оголошена), а знищується при виході з блоку, в якому вона оголошена.</p>

<pre>
<code class="language-cpp">int factorial (int n)
{
   int result = 1;
   for (int i = 1; i &lt;= n; i++)
   {
       result *= i;
   }
   return result;
}

int main()
{
   int number;
   cin &gt;&gt;number;
   cout &lt;&lt;factorial(number) &lt;&lt;endl;
   return 0;
}</code></pre>

<p>У цьому прикладі пам&#39;ять виділяється автоматично під змінні <code>result</code> (існує до виходу з функції), <code>i</code>, яка існує тільки в циклі <strong><code>for</code></strong>, а також під формальний параметр <code>n</code> (нагадаємо, що передача відбувається за значенням, тобто змінна&nbsp;<code>n</code> буде копією змінної <code> number</code>).</p>

<p>Також автоматично пам&#39;ять розподіляється під тимчасові об&#39;єкти. Тимчасові об&#39;єкти (або анонімні, безіменні об&#39;єкти) &mdash; це об&#39;єкти, які компілятор створює автоматично під час обчислення виразів. Такі об&#39;єкти не мають імені та знищуються відразу ж, як тільки в них зникає потреба. Тобто. вони існують тільки в рамках оператора, де вони створюються.</p>

<p>Наприклад, тимчасовим значенням буде результат функції&nbsp;<code>factorial(number)</code>. Пам&#39;ять під нього звільниться одразу після закінчення роботи оператора&nbsp;<code>cout &lt;&lt;factorial(number) &lt;&lt;endl;</code>.</p>

<p>Автоматичні змінні, а також тимчасові (безіменні) значення розташовуються в стеку.</p>

<h3>2. Статичне виділення пам&#39;яті</h3>

<p>Використовується для всіх глобальних змінних. Також для локальних змінних, оголошених зі словом <code><strong>static</strong></code>.</p>

<p>Найкласичніший варіант застосування статичних локальних змінних - це функція, яка рахує, скільки разів вона запущена. Якщо ми напишемо функцію так:</p>

<pre>
<code>int count_calls()
{
    int counter = 0;
    counter++;
    return counter;
}</code></pre>

<p>то переменная <code>counter</code> будет создаваться заново при каждом вызове функции <code>count_calls()</code> и каждый раз она будет инициализироваться нулем, поэтому функция всегда будет возвращать единицу.</p>

<p>Если же применить модификатор <code><strong>static</strong></code> для переменной <code>counter</code>, то под неё память будет выделяться статически и её инициализация произойдет один раз. В дальнейшем эта переменная будет оставаться в памяти:</p>

<pre>
<code>int count_calls()
{
    static int counter = 0;
    counter++;
    return counter;
}</code></pre>

<p>В данном варианте функция&nbsp;<code>count_calls()</code> вернет единицу&nbsp;только при первом вызове, а затем будет выдавать всё большие и большие числа. Заметим, что переменная&nbsp;&nbsp;<code>counter</code> останется при этом локальной, т.е. будет доступна только из функции <code>count_calls()</code>.</p>

<p>Статически выделенные данные располагаются в сегменте данных программы.</p>

<h3>3. Динамічне виділення пам&#39;яті</h3>

<p>Отже є змінні з кототкою довжиною життя - автоматичні. Звичайно, автоматична змінна, оголошена в основному блоці функції <code>main</code> проживе до кінця роботи програми, але принципи декомпозиції коду призводять до того, що ми пишемо багато різних функцій і, як ми переконалися, автоматичні змінні, оголошені в функції не можуть жити довше, ніж час роботи функції. Функція завершує роботу та змінна знищується, пам&#39;ять звільняється. Це дуже надійно та зручно, але не гнучко.</p>

<p>З іншого боку, час життя статичних змінних (неважливо, глобальних чи локальних) максимально, пам&#39;ять звільняється лише наприкінці роботи програми. Це теж надійно та зручно, але теж не гнучко &ndash; пам&#39;ять зайнята під час роботи програми.</p>

<p>Уявімо таке завдання. Нехай програма обробляє зображення або великий текстовий файл. Може бути функція зчитування зображення або текстового файлу з диска в оперативну пам&#39;ять комп&#39;ютера. Питання: який спосіб виділення пам&#39;яті цю функцію можна використовувати? Якщо вона буде використовувати автоматичне виділення пам&#39;яті, то пам&#39;ять буде очищена після виходу з функції - що неправильно, функція тільки завантажує інформацію з диска, обробка буде відбуватися в інших функціях - після виходу з функції завантаження. Можна, звичайно, використовувати статичне виділення пам&#39;яті, але це призведе до наступних результатів:</p>

<ol>
	<li>Пам&#39;ять буде виділено завжди, коли вона потрібна, чи не потрібна, байдуже.</li>
	<li>Буде виділено певну кількість пам&#39;яті. Звичайно, якщо нам потрібно більше одного об&#39;єкта, наприклад, більше одного зображення, то можна завести статичний масив, але тоді максимальна кількість і максимальний розмір зображень буде чітко зафіксований. Наприклад, ми можемо домовитися, що зберігається не більше 10 зображень з роздільною здатністю не більше ніж 1024 на 1024 пікселі... І пам&#39;ять буде зарезервована саме на таку кількість та розмір зображень.</li>
</ol>

<p>Отже, нам потрібний більш гнучкий і універсальний метод виділення пам&#39;яті, щоб пам&#39;ять можна було виділити в той момент, коли потрібно і потім звільнити, коли вже немає потреби в зберіганні даних.</p>

<p>При динамічному розподілі пам&#39;яті об&#39;єкти розміщуються в області пам&#39;яті, яка називається &laquo;<em>купою</em>&raquo; (англ. <em>heap</em>): при конструюванні об&#39;єкта вказується розмір пам&#39;яті, що запитується під об&#39;єкт, і, у разі успіху, виділена область пам&#39;яті позначається зайнятою, стаючи недоступною при наступних операціях виділення пам&#39;яті . Протилежна за змістом операція - звільнення зайнятої раніше під будь-який об&#39;єкт пам&#39;яті: пам&#39;ять, що звільняється, стає доступною при подальших операціях виділення пам&#39;яті.</p>

<p>Працюючи з купою може бути дві неприємні ситуації:</p>

<ol>
	<li>Витік памяті. Витіком називається ситуація, коли виділена пам&#39;ять вже ніяк недоступна в програмі, але при цьому вона не звільнена (наприклад, програміст забув викликати операцію звільнення пам&#39;яті). При цьому до кінця роботи програми цю пам&#39;ять вже не буде звільнено і працювати програма з нею теж не може. У мові C++ боротися з витоками пам&#39;яті допомагають розумні вказівники, які гарантують своєчасне звільнення пам&#39;яті (при правильному їх використанні) &mdash; таким чином, викликати вручну звільнення пам&#39;яті вже непотрібно. Але повністю цю проблему може вирішити лише прибиральник&nbsp;сміття, який не реалізований у стандартному C і C++, на відміну від багатьох інших мов, наприклад, як C# та Java. Прибиральник&nbsp;сміття іноді аналізує виділену пам&#39;ять і автоматично звільняє ділянки пам&#39;яті, які вже недоступні в програмі. Тим не менш, прибиральник&nbsp;сміття, хоч і зручний, призводить до деяких накладних витрат (за продуктивністю програми) - тому не у всіх випадках він застосовний.</li>
	<li>Фрагментація пам&#39;яті. Виділення пам&#39;яті відбувається блоками - безперервними фрагментами оперативної пам&#39;яті (таким чином, кожен блок - це кілька байт, що йдуть поспіль). Якщо потім якийсь блок із середини купи буде звільнено, то в купі залишиться деяка вільна область, окрема від інших вільних областей. У якийсь момент у купі може не виявитися вільного безперервного блоку відповідного розміру і, навіть якщо сумарна кількість вільної пам&#39;яті достатньо для розміщення об&#39;єкта, операція виділення пам&#39;яті закінчиться невдачею.</li>
</ol>

<p><strong>Литература:</strong></p>

<ol>
	<li>Динамическое выделение памяти в C++ | Уроки С++ &mdash; Ravesli - <a href="https://ravesli.com/urok-85-dinamicheskoe-vydelenie-pamyati-operatory-new-i-delete/" rel="noopener noreferrer nofollow">https://ravesli.com/urok-85-dinamicheskoe-vydelenie-pamyati-operatory-new-i-delete/</a></li>
	<li>Динамічне виділення пам&#39;яті &mdash; Вікіпедія&nbsp;&mdash;&nbsp;<a href="https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B5_%D0%B2%D0%B8%D0%B4%D1%96%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F_%D0%BF%D0%B0%D0%BC%27%D1%8F%D1%82%D1%96" rel="noopener noreferrer nofollow">https://uk.wikipedia.org/wiki/Динамічне_виділення_пам%27яті</a></li>
	<li>Тимчасовий об&#39;єкт &mdash; Вікіпедія&nbsp;&mdash;&nbsp;<a href="https://uk.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BC%D1%87%D0%B0%D1%81%D0%BE%D0%B2%D0%B8%D0%B9_%D0%BE%D0%B1%27%D1%94%D0%BA%D1%82" rel="noopener noreferrer nofollow">https://uk.wikipedia.org/wiki/Тимчасовий_об%27єкт</a></li>
	<li>Анонимные объекты | Уроки С++ &mdash; Ravesli&nbsp;&mdash; <a href="https://ravesli.com/urok-127-anonimnye-obekty/" rel="noopener noreferrer nofollow">https://ravesli.com/urok-127-anonimnye-obekty/</a></li>
</ol>
